"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _memize = _interopRequireDefault(require("memize"));

var _lodash = require("lodash");

var _reactNative = require("react-native");

var _editor = require("@wordpress/editor");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _reactNativeBridge = require("@wordpress/react-native-bridge");

var _components = require("@wordpress/components");

var _coreData = require("@wordpress/core-data");

var _layout = _interopRequireDefault(require("./components/layout"));

var _store = require("./store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
class Editor extends _element.Component {
  constructor(props) {
    super(...arguments);

    if (props.initialHtmlModeEnabled && props.mode === 'visual') {
      // enable html mode if the initial mode the parent wants it but we're not already in it
      this.props.switchEditorMode('text');
    }

    this.getEditorSettings = (0, _memize.default)(this.getEditorSettings, {
      maxSize: 1
    });
    this.setTitleRef = this.setTitleRef.bind(this);
  }

  getEditorSettings(settings, hasFixedToolbar, focusMode, hiddenBlockTypes, blockTypes) {
    settings = { ...settings,
      isRTL: _reactNative.I18nManager.isRTL,
      hasFixedToolbar,
      focusMode
    }; // Omit hidden block types if exists and non-empty.

    if ((0, _lodash.size)(hiddenBlockTypes) > 0) {
      if (settings.allowedBlockTypes === undefined) {
        // if no specific flags for allowedBlockTypes are set, assume `true`
        // meaning allow all block types
        settings.allowedBlockTypes = true;
      } // Defer to passed setting for `allowedBlockTypes` if provided as
      // anything other than `true` (where `true` is equivalent to allow
      // all block types).


      const defaultAllowedBlockTypes = true === settings.allowedBlockTypes ? (0, _lodash.map)(blockTypes, 'name') : settings.allowedBlockTypes || [];
      settings.allowedBlockTypes = (0, _lodash.without)(defaultAllowedBlockTypes, ...hiddenBlockTypes);
    }

    return settings;
  }

  componentDidMount() {
    const {
      editEntityRecord,
      postType,
      postId
    } = this.props;
    this.subscriptionParentSetFocusOnTitle = (0, _reactNativeBridge.subscribeSetFocusOnTitle)(() => {
      if (this.postTitleRef) {
        this.postTitleRef.focus();
      }
    });
    this.subscriptionParentFeaturedImageIdNativeUpdated = (0, _reactNativeBridge.subscribeFeaturedImageIdNativeUpdated)(payload => {
      editEntityRecord('postType', postType, postId, {
        featured_media: payload.featuredImageId
      }, {
        undoIgnore: true
      });
    });
  }

  componentWillUnmount() {
    if (this.subscriptionParentSetFocusOnTitle) {
      this.subscriptionParentSetFocusOnTitle.remove();
    }

    if (this.subscribeFeaturedImageIdNativeUpdated) {
      this.subscribeFeaturedImageIdNativeUpdated.remove();
    }
  }

  setTitleRef(titleRef) {
    this.postTitleRef = titleRef;
  }

  render() {
    const {
      settings,
      hasFixedToolbar,
      focusMode,
      initialEdits,
      hiddenBlockTypes,
      blockTypes,
      post,
      postId,
      postType,
      featuredImageId,
      initialHtml,
      ...props
    } = this.props;
    const editorSettings = this.getEditorSettings(settings, hasFixedToolbar, focusMode, hiddenBlockTypes, blockTypes);
    const normalizedPost = post || {
      id: postId,
      title: {
        raw: props.initialTitle || ''
      },
      featured_media: featuredImageId,
      content: {
        // make sure the post content is in sync with gutenberg store
        // to avoid marking the post as modified when simply loaded
        // For now, let's assume: serialize( parse( html ) ) !== html
        raw: (0, _blocks.serialize)((0, _blocks.parse)(initialHtml || ''))
      },
      type: postType,
      status: 'draft',
      meta: []
    };
    return (0, _element.createElement)(_components.SlotFillProvider, null, (0, _element.createElement)(_editor.EditorProvider, (0, _extends2.default)({
      settings: editorSettings,
      post: normalizedPost,
      initialEdits: initialEdits,
      useSubRegistry: false
    }, props), (0, _element.createElement)(_layout.default, {
      setTitleRef: this.setTitleRef
    })));
  }

}

var _default = (0, _compose.compose)([(0, _data.withSelect)(select => {
  const {
    isFeatureActive,
    getEditorMode,
    getPreference,
    __experimentalGetPreviewDeviceType
  } = select(_store.store);
  const {
    getBlockTypes
  } = select(_blocks.store);
  return {
    hasFixedToolbar: isFeatureActive('fixedToolbar') || __experimentalGetPreviewDeviceType() !== 'Desktop',
    focusMode: isFeatureActive('focusMode'),
    mode: getEditorMode(),
    hiddenBlockTypes: getPreference('hiddenBlockTypes'),
    blockTypes: getBlockTypes()
  };
}), (0, _data.withDispatch)(dispatch => {
  const {
    switchEditorMode
  } = dispatch(_store.store);
  const {
    editEntityRecord
  } = dispatch(_coreData.store);
  return {
    switchEditorMode,
    editEntityRecord
  };
})])(Editor);

exports.default = _default;
//# sourceMappingURL=editor.native.js.map