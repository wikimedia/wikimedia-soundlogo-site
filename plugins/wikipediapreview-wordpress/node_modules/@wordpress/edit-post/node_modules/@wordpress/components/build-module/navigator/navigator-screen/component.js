import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports
// eslint-disable-next-line no-restricted-imports
import { motion } from 'framer-motion';
/**
 * WordPress dependencies
 */

import { useContext, useEffect, useState } from '@wordpress/element';
import { useReducedMotion, useFocusOnMount } from '@wordpress/compose';
import { isRTL } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import { contextConnect, useContextSystem } from '../../ui/context';
import { View } from '../../view';
import { NavigatorContext } from '../context';
const animationEnterDelay = 0;
const animationEnterDuration = 0.14;
const animationExitDuration = 0.14;
const animationExitDelay = 0; // Props specific to `framer-motion` can't be currently passed to `NavigatorScreen`,
// as some of them would overlap with HTML props (e.g. `onAnimationStart`, ...)

function NavigatorScreen(props, forwardedRef) {
  const {
    children,
    path,
    ...otherProps
  } = useContextSystem(props, 'NavigatorScreen');
  const prefersReducedMotion = useReducedMotion();
  const [currentPath] = useContext(NavigatorContext);
  const isMatch = currentPath.path === path;
  const ref = useFocusOnMount(); // This flag is used to only apply the focus on mount when the actual path changes.
  // It avoids the focus to happen on the first render.

  const [hasPathChanged, setHasPathChanged] = useState(false);
  useEffect(() => {
    setHasPathChanged(true);
  }, [path]);

  if (!isMatch) {
    return null;
  }

  if (prefersReducedMotion) {
    return createElement(View, _extends({
      ref: forwardedRef
    }, otherProps), children);
  }

  const animate = {
    opacity: 1,
    transition: {
      delay: animationEnterDelay,
      duration: animationEnterDuration,
      ease: 'easeInOut'
    },
    x: 0
  };
  const initial = {
    opacity: 0,
    x: isRTL() && currentPath.isBack || !isRTL() && !currentPath.isBack ? 50 : -50
  };
  const exit = {
    delay: animationExitDelay,
    opacity: 0,
    x: !isRTL() && currentPath.isBack || isRTL() && !currentPath.isBack ? 50 : -50,
    transition: {
      duration: animationExitDuration,
      ease: 'easeInOut'
    }
  };
  const animatedProps = {
    animate,
    exit,
    initial
  };
  return createElement(motion.div, _extends({
    ref: hasPathChanged ? ref : undefined
  }, otherProps, animatedProps), children);
}
/**
 * The `NavigatorScreen` component represents a single view/screen/panel/menu and is supposed to be used in combination with the `NavigatorProvider` component.
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalUseNavigator as useNavigator,
 * } from '@wordpress/components';
 *
 * function NavigatorButton( {
 *   path,
 *   isBack = false,
 *   ...props
 * } ) {
 *   const navigator = useNavigator();
 *   return (
 *   	<Button
 *   	  onClick={ () => navigator.push( path, { isBack } ) }
 *   	  { ...props }
 *   	/>
 *   );
 * }
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *   	   <NavigatorButton isPrimary path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorButton isPrimary path="/" isBack>
 *         Go back
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */


const ConnectedNavigatorScreen = contextConnect(NavigatorScreen, 'NavigatorScreen');
export default ConnectedNavigatorScreen;
//# sourceMappingURL=component.js.map