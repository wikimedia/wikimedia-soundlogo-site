import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import { get } from 'lodash';
/**
 * WordPress dependencies
 */

import { __experimentalNavigatorProvider as NavigatorProvider, __experimentalNavigatorScreen as NavigatorScreen, __experimentalUseNavigator as useNavigator, __experimentalItemGroup as ItemGroup, __experimentalItem as Item, __experimentalHStack as HStack, __experimentalTruncate as Truncate, FlexItem, Modal, TabPanel, Button, Card, CardBody } from '@wordpress/components';
import { isRTL, __ } from '@wordpress/i18n';
import { useViewportMatch } from '@wordpress/compose';
import { useSelect, useDispatch } from '@wordpress/data';
import { useMemo, useCallback, useState } from '@wordpress/element';
import { PostTaxonomies, PostExcerptCheck, PageAttributesCheck, PostFeaturedImageCheck, PostTypeSupportCheck, store as editorStore } from '@wordpress/editor';
import { store as coreStore } from '@wordpress/core-data';
import { chevronLeft, chevronRight, Icon } from '@wordpress/icons';
/**
 * Internal dependencies
 */

import Section from './section';
import { EnablePluginDocumentSettingPanelOption, EnablePublishSidebarOption, EnablePanelOption, EnableFeature } from './options';
import MetaBoxesSection from './meta-boxes-section';
import { store as editPostStore } from '../../store';
import BlockManager from '../block-manager';
const MODAL_NAME = 'edit-post/preferences';
const PREFERENCES_MENU = 'preferences-menu';

function NavigationButton({
  as: Tag = Button,
  path,
  isBack = false,
  ...props
}) {
  const navigator = useNavigator();
  return createElement(Tag, _extends({
    onClick: () => navigator.push(path, {
      isBack
    })
  }, props));
}

export default function PreferencesModal() {
  const isLargeViewport = useViewportMatch('medium');
  const {
    closeModal
  } = useDispatch(editPostStore);
  const {
    isModalActive,
    isViewable
  } = useSelect(select => {
    const {
      getEditedPostAttribute
    } = select(editorStore);
    const {
      getPostType
    } = select(coreStore);
    const postType = getPostType(getEditedPostAttribute('type'));
    return {
      isModalActive: select(editPostStore).isModalActive(MODAL_NAME),
      isViewable: get(postType, ['viewable'], false)
    };
  }, []);
  const showBlockBreadcrumbsOption = useSelect(select => {
    const {
      getEditorSettings
    } = select(editorStore);
    const {
      getEditorMode,
      isFeatureActive
    } = select(editPostStore);
    const mode = getEditorMode();
    const isRichEditingEnabled = getEditorSettings().richEditingEnabled;
    const hasReducedUI = isFeatureActive('reducedUI');
    return !hasReducedUI && isLargeViewport && isRichEditingEnabled && mode === 'visual';
  }, [isLargeViewport]);
  const sections = useMemo(() => [{
    name: 'general',
    tabLabel: __('General'),
    content: createElement(Fragment, null, isLargeViewport && createElement(Section, {
      title: __('Publishing'),
      description: __('Change options related to publishing.')
    }, createElement(EnablePublishSidebarOption, {
      help: __('Review settings, such as visibility and tags.'),
      label: __('Include pre-publish checklist')
    })), createElement(Section, {
      title: __('Appearance'),
      description: __('Customize options related to the block editor interface and editing flow.')
    }, createElement(EnableFeature, {
      featureName: "reducedUI",
      help: __('Compacts options and outlines in the toolbar.'),
      label: __('Reduce the interface')
    }), createElement(EnableFeature, {
      featureName: "focusMode",
      help: __('Highlights the current block and fades other content.'),
      label: __('Spotlight mode')
    }), createElement(EnableFeature, {
      featureName: "showIconLabels",
      help: __('Shows text instead of icons.'),
      label: __('Display button labels')
    }), createElement(EnableFeature, {
      featureName: "themeStyles",
      help: __('Make the editor look like your theme.'),
      label: __('Use theme styles')
    }), showBlockBreadcrumbsOption && createElement(EnableFeature, {
      featureName: "showBlockBreadcrumbs",
      help: __('Shows block breadcrumbs at the bottom of the editor.'),
      label: __('Display block breadcrumbs')
    })))
  }, {
    name: 'blocks',
    tabLabel: __('Blocks'),
    content: createElement(Fragment, null, createElement(Section, {
      title: __('Block interactions'),
      description: __('Customize how you interact with blocks in the block library and editing canvas.')
    }, createElement(EnableFeature, {
      featureName: "mostUsedBlocks",
      help: __('Places the most frequent blocks in the block library.'),
      label: __('Show most used blocks')
    }), createElement(EnableFeature, {
      featureName: "keepCaretInsideBlock",
      help: __('Aids screen readers by stopping text caret from leaving blocks.'),
      label: __('Contain text cursor inside block')
    })), createElement(Section, {
      title: __('Visible blocks'),
      description: __("Disable blocks that you don't want to appear in the inserter. They can always be toggled back on later.")
    }, createElement(BlockManager, null)))
  }, {
    name: 'panels',
    tabLabel: __('Panels'),
    content: createElement(Fragment, null, createElement(Section, {
      title: __('Document settings'),
      description: __('Choose what displays in the panel.')
    }, createElement(EnablePluginDocumentSettingPanelOption.Slot, null), isViewable && createElement(EnablePanelOption, {
      label: __('Permalink'),
      panelName: "post-link"
    }), isViewable && createElement(EnablePanelOption, {
      label: __('Template'),
      panelName: "template"
    }), createElement(PostTaxonomies, {
      taxonomyWrapper: (content, taxonomy) => createElement(EnablePanelOption, {
        label: get(taxonomy, ['labels', 'menu_name']),
        panelName: `taxonomy-panel-${taxonomy.slug}`
      })
    }), createElement(PostFeaturedImageCheck, null, createElement(EnablePanelOption, {
      label: __('Featured image'),
      panelName: "featured-image"
    })), createElement(PostExcerptCheck, null, createElement(EnablePanelOption, {
      label: __('Excerpt'),
      panelName: "post-excerpt"
    })), createElement(PostTypeSupportCheck, {
      supportKeys: ['comments', 'trackbacks']
    }, createElement(EnablePanelOption, {
      label: __('Discussion'),
      panelName: "discussion-panel"
    })), createElement(PageAttributesCheck, null, createElement(EnablePanelOption, {
      label: __('Page attributes'),
      panelName: "page-attributes"
    }))), createElement(MetaBoxesSection, {
      title: __('Additional'),
      description: __('Add extra areas to the editor.')
    }))
  }], [isViewable, isLargeViewport, showBlockBreadcrumbsOption]); // This is also used to sync the two different rendered components
  // between small and large viewports.

  const [activeMenu, setActiveMenu] = useState(PREFERENCES_MENU);
  /**
   * Create helper objects from `sections` for easier data handling.
   * `tabs` is used for creating the `TabPanel` and `sectionsContentMap`
   * is used for easier access to active tab's content.
   */

  const {
    tabs,
    sectionsContentMap
  } = useMemo(() => sections.reduce((accumulator, {
    name,
    tabLabel: title,
    content
  }) => {
    accumulator.tabs.push({
      name,
      title
    });
    accumulator.sectionsContentMap[name] = content;
    return accumulator;
  }, {
    tabs: [],
    sectionsContentMap: {}
  }), [sections]);
  const getCurrentTab = useCallback(tab => sectionsContentMap[tab.name] || null, [sectionsContentMap]);

  if (!isModalActive) {
    return null;
  }

  let modalContent; // We render different components based on the viewport size.

  if (isLargeViewport) {
    modalContent = createElement(TabPanel, {
      className: "edit-post-preferences__tabs",
      tabs: tabs,
      initialTabName: activeMenu !== PREFERENCES_MENU ? activeMenu : undefined,
      onSelect: setActiveMenu,
      orientation: "vertical"
    }, getCurrentTab);
  } else {
    modalContent = createElement(Card, {
      isBorderless: true
    }, createElement(CardBody, null, createElement(NavigatorProvider, {
      initialPath: "/"
    }, createElement(NavigatorScreen, {
      path: "/"
    }, createElement(ItemGroup, null, tabs.map(tab => {
      return createElement(NavigationButton, {
        key: tab.name,
        path: tab.name,
        as: Item,
        isAction: true
      }, createElement(HStack, {
        justify: "space-between"
      }, createElement(FlexItem, null, createElement(Truncate, null, tab.title)), createElement(FlexItem, null, createElement(Icon, {
        icon: isRTL() ? chevronLeft : chevronRight
      }))));
    }))), sections.map(section => {
      return createElement(NavigatorScreen, {
        key: `${section.name}-menu`,
        path: section.name
      }, createElement(NavigationButton, {
        path: "/",
        icon: isRTL() ? chevronRight : chevronLeft,
        isBack: true,
        "aria-label": __('Navigate to the previous view')
      }, __('Back')), createElement("h2", null, section.tabLabel), section.content);
    }))));
  }

  return createElement(Modal, {
    className: "edit-post-preferences-modal",
    title: __('Preferences'),
    closeLabel: __('Close'),
    onRequestClose: closeModal
  }, modalContent);
}
//# sourceMappingURL=index.js.map