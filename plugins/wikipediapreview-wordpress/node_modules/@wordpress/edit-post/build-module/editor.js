import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { size, map, without } from 'lodash';
/**
 * WordPress dependencies
 */

import { store as blocksStore } from '@wordpress/blocks';
import { useSelect, useDispatch } from '@wordpress/data';
import { EditorProvider, ErrorBoundary, PostLockedModal, store as editorStore } from '@wordpress/editor';
import { StrictMode, useMemo } from '@wordpress/element';
import { KeyboardShortcuts, SlotFillProvider } from '@wordpress/components';
import { store as coreStore } from '@wordpress/core-data';
import { ShortcutProvider } from '@wordpress/keyboard-shortcuts';
/**
 * Internal dependencies
 */

import preventEventDiscovery from './prevent-event-discovery';
import Layout from './components/layout';
import EditorInitialization from './components/editor-initialization';
import EditPostSettings from './components/edit-post-settings';
import { store as editPostStore } from './store';

function Editor({
  postId,
  postType,
  settings,
  initialEdits,
  onError,
  ...props
}) {
  const {
    hasFixedToolbar,
    focusMode,
    hasReducedUI,
    hasThemeStyles,
    post,
    preferredStyleVariations,
    hiddenBlockTypes,
    blockTypes,
    __experimentalLocalAutosaveInterval,
    keepCaretInsideBlock,
    isTemplateMode,
    template
  } = useSelect(select => {
    var _getPostType$viewable, _getPostType;

    const {
      isFeatureActive,
      getPreference,
      __experimentalGetPreviewDeviceType,
      isEditingTemplate,
      getEditedPostTemplate
    } = select(editPostStore);
    const {
      getEntityRecord,
      getPostType,
      getEntityRecords
    } = select(coreStore);
    const {
      getEditorSettings
    } = select(editorStore);
    const {
      getBlockTypes
    } = select(blocksStore);
    const isTemplate = ['wp_template', 'wp_template_part'].includes(postType); // Ideally the initializeEditor function should be called using the ID of the REST endpoint.
    // to avoid the special case.

    let postObject;

    if (isTemplate) {
      const posts = getEntityRecords('postType', postType, {
        wp_id: postId
      });
      postObject = posts === null || posts === void 0 ? void 0 : posts[0];
    } else {
      postObject = getEntityRecord('postType', postType, postId);
    }

    const supportsTemplateMode = getEditorSettings().supportsTemplateMode;
    const isViewable = (_getPostType$viewable = (_getPostType = getPostType(postType)) === null || _getPostType === void 0 ? void 0 : _getPostType.viewable) !== null && _getPostType$viewable !== void 0 ? _getPostType$viewable : false;
    return {
      hasFixedToolbar: isFeatureActive('fixedToolbar') || __experimentalGetPreviewDeviceType() !== 'Desktop',
      focusMode: isFeatureActive('focusMode'),
      hasReducedUI: isFeatureActive('reducedUI'),
      hasThemeStyles: isFeatureActive('themeStyles'),
      preferredStyleVariations: getPreference('preferredStyleVariations'),
      hiddenBlockTypes: getPreference('hiddenBlockTypes'),
      blockTypes: getBlockTypes(),
      __experimentalLocalAutosaveInterval: getPreference('localAutosaveInterval'),
      keepCaretInsideBlock: isFeatureActive('keepCaretInsideBlock'),
      isTemplateMode: isEditingTemplate(),
      template: supportsTemplateMode && isViewable ? getEditedPostTemplate() : null,
      post: postObject
    };
  }, [postType, postId]);
  const {
    updatePreferredStyleVariations,
    setIsInserterOpened
  } = useDispatch(editPostStore);
  const editorSettings = useMemo(() => {
    const result = { ...settings,
      __experimentalPreferredStyleVariations: {
        value: preferredStyleVariations,
        onChange: updatePreferredStyleVariations
      },
      hasFixedToolbar,
      focusMode,
      hasReducedUI,
      __experimentalLocalAutosaveInterval,
      // This is marked as experimental to give time for the quick inserter to mature.
      __experimentalSetIsInserterOpened: setIsInserterOpened,
      keepCaretInsideBlock
    }; // Omit hidden block types if exists and non-empty.

    if (size(hiddenBlockTypes) > 0) {
      // Defer to passed setting for `allowedBlockTypes` if provided as
      // anything other than `true` (where `true` is equivalent to allow
      // all block types).
      const defaultAllowedBlockTypes = true === settings.allowedBlockTypes ? map(blockTypes, 'name') : settings.allowedBlockTypes || [];
      result.allowedBlockTypes = without(defaultAllowedBlockTypes, ...hiddenBlockTypes);
    }

    return result;
  }, [settings, hasFixedToolbar, focusMode, hasReducedUI, hiddenBlockTypes, blockTypes, preferredStyleVariations, __experimentalLocalAutosaveInterval, setIsInserterOpened, updatePreferredStyleVariations, keepCaretInsideBlock]);
  const styles = useMemo(() => {
    var _settings$styles;

    return hasThemeStyles && (_settings$styles = settings.styles) !== null && _settings$styles !== void 0 && _settings$styles.length ? settings.styles : settings.defaultEditorStyles;
  }, [settings, hasThemeStyles]);

  if (!post) {
    return null;
  }

  return createElement(StrictMode, null, createElement(ShortcutProvider, null, createElement(EditPostSettings.Provider, {
    value: settings
  }, createElement(SlotFillProvider, null, createElement(EditorProvider, _extends({
    settings: editorSettings,
    post: post,
    initialEdits: initialEdits,
    useSubRegistry: false,
    __unstableTemplate: isTemplateMode ? template : undefined
  }, props), createElement(ErrorBoundary, {
    onError: onError
  }, createElement(EditorInitialization, {
    postId: postId
  }), createElement(Layout, {
    styles: styles
  }), createElement(KeyboardShortcuts, {
    shortcuts: preventEventDiscovery
  })), createElement(PostLockedModal, null))))));
}

export default Editor;
//# sourceMappingURL=editor.js.map