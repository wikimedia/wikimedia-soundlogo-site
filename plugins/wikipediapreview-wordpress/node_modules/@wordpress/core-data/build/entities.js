"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKindEntities = exports.getMethodName = exports.prePersistPostType = exports.kinds = exports.defaultEntities = exports.DEFAULT_ENTITY_KEY = void 0;

var _lodash = require("lodash");

var _apiFetch = _interopRequireDefault(require("@wordpress/api-fetch"));

var _i18n = require("@wordpress/i18n");

var _actions = require("./actions");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const DEFAULT_ENTITY_KEY = 'id';
exports.DEFAULT_ENTITY_KEY = DEFAULT_ENTITY_KEY;
const POST_RAW_ATTRIBUTES = ['title', 'excerpt', 'content'];
const defaultEntities = [{
  label: (0, _i18n.__)('Base'),
  name: '__unstableBase',
  kind: 'root',
  baseURL: ''
}, {
  label: (0, _i18n.__)('Site'),
  name: 'site',
  kind: 'root',
  baseURL: '/wp/v2/settings',
  getTitle: record => {
    return (0, _lodash.get)(record, ['title'], (0, _i18n.__)('Site Title'));
  }
}, {
  label: (0, _i18n.__)('Post Type'),
  name: 'postType',
  kind: 'root',
  key: 'slug',
  baseURL: '/wp/v2/types',
  baseURLParams: {
    context: 'edit'
  },
  rawAttributes: POST_RAW_ATTRIBUTES
}, {
  name: 'media',
  kind: 'root',
  baseURL: '/wp/v2/media',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'mediaItems',
  label: (0, _i18n.__)('Media')
}, {
  name: 'taxonomy',
  kind: 'root',
  key: 'slug',
  baseURL: '/wp/v2/taxonomies',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'taxonomies',
  label: (0, _i18n.__)('Taxonomy')
}, {
  name: 'sidebar',
  kind: 'root',
  baseURL: '/wp/v2/sidebars',
  plural: 'sidebars',
  transientEdits: {
    blocks: true
  },
  label: (0, _i18n.__)('Widget areas')
}, {
  name: 'widget',
  kind: 'root',
  baseURL: '/wp/v2/widgets',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'widgets',
  transientEdits: {
    blocks: true
  },
  label: (0, _i18n.__)('Widgets')
}, {
  name: 'widgetType',
  kind: 'root',
  baseURL: '/wp/v2/widget-types',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'widgetTypes',
  label: (0, _i18n.__)('Widget types')
}, {
  label: (0, _i18n.__)('User'),
  name: 'user',
  kind: 'root',
  baseURL: '/wp/v2/users',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'users'
}, {
  name: 'comment',
  kind: 'root',
  baseURL: '/wp/v2/comments',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'comments',
  label: (0, _i18n.__)('Comment')
}, {
  name: 'menu',
  kind: 'root',
  baseURL: '/__experimental/menus',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'menus',
  label: (0, _i18n.__)('Menu')
}, {
  name: 'menuItem',
  kind: 'root',
  baseURL: '/__experimental/menu-items',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'menuItems',
  label: (0, _i18n.__)('Menu Item'),
  rawAttributes: ['title', 'content']
}, {
  name: 'menuLocation',
  kind: 'root',
  baseURL: '/__experimental/menu-locations',
  baseURLParams: {
    context: 'edit'
  },
  plural: 'menuLocations',
  label: (0, _i18n.__)('Menu Location'),
  key: 'name'
}];
exports.defaultEntities = defaultEntities;
const kinds = [{
  name: 'postType',
  loadEntities: loadPostTypeEntities
}, {
  name: 'taxonomy',
  loadEntities: loadTaxonomyEntities
}];
/**
 * Returns a function to be used to retrieve extra edits to apply before persisting a post type.
 *
 * @param {Object} persistedRecord Already persisted Post
 * @param {Object} edits           Edits.
 * @return {Object} Updated edits.
 */

exports.kinds = kinds;

const prePersistPostType = (persistedRecord, edits) => {
  const newEdits = {};

  if ((persistedRecord === null || persistedRecord === void 0 ? void 0 : persistedRecord.status) === 'auto-draft') {
    // Saving an auto-draft should create a draft by default.
    if (!edits.status && !newEdits.status) {
      newEdits.status = 'draft';
    } // Fix the auto-draft default title.


    if ((!edits.title || edits.title === 'Auto Draft') && !newEdits.title && (!(persistedRecord !== null && persistedRecord !== void 0 && persistedRecord.title) || (persistedRecord === null || persistedRecord === void 0 ? void 0 : persistedRecord.title) === 'Auto Draft')) {
      newEdits.title = '';
    }
  }

  return newEdits;
};
/**
 * Returns the list of post type entities.
 *
 * @return {Promise} Entities promise
 */


exports.prePersistPostType = prePersistPostType;

async function loadPostTypeEntities() {
  const postTypes = await (0, _apiFetch.default)({
    path: '/wp/v2/types?context=edit'
  });
  return (0, _lodash.map)(postTypes, (postType, name) => {
    const isTemplate = ['wp_template', 'wp_template_part'].includes(name);
    return {
      kind: 'postType',
      baseURL: '/wp/v2/' + postType.rest_base,
      baseURLParams: {
        context: 'edit'
      },
      name,
      label: postType.labels.singular_name,
      transientEdits: {
        blocks: true,
        selection: true
      },
      mergedEdits: {
        meta: true
      },
      rawAttributes: POST_RAW_ATTRIBUTES,
      getTitle: record => {
        var _record$title;

        return (record === null || record === void 0 ? void 0 : (_record$title = record.title) === null || _record$title === void 0 ? void 0 : _record$title.rendered) || (record === null || record === void 0 ? void 0 : record.title) || (isTemplate ? (0, _lodash.startCase)(record.slug) : String(record.id));
      },
      __unstablePrePersist: isTemplate ? undefined : prePersistPostType,
      __unstable_rest_base: postType.rest_base
    };
  });
}
/**
 * Returns the list of the taxonomies entities.
 *
 * @return {Promise} Entities promise
 */


async function loadTaxonomyEntities() {
  const taxonomies = await (0, _apiFetch.default)({
    path: '/wp/v2/taxonomies?context=edit'
  });
  return (0, _lodash.map)(taxonomies, (taxonomy, name) => {
    return {
      kind: 'taxonomy',
      baseURL: '/wp/v2/' + taxonomy.rest_base,
      baseURLParams: {
        context: 'edit'
      },
      name,
      label: taxonomy.labels.singular_name
    };
  });
}
/**
 * Returns the entity's getter method name given its kind and name.
 *
 * @param {string}  kind      Entity kind.
 * @param {string}  name      Entity name.
 * @param {string}  prefix    Function prefix.
 * @param {boolean} usePlural Whether to use the plural form or not.
 *
 * @return {string} Method name
 */


const getMethodName = (kind, name, prefix = 'get', usePlural = false) => {
  const entity = (0, _lodash.find)(defaultEntities, {
    kind,
    name
  });
  const kindPrefix = kind === 'root' ? '' : (0, _lodash.upperFirst)((0, _lodash.camelCase)(kind));
  const nameSuffix = (0, _lodash.upperFirst)((0, _lodash.camelCase)(name)) + (usePlural ? 's' : '');
  const suffix = usePlural && entity.plural ? (0, _lodash.upperFirst)((0, _lodash.camelCase)(entity.plural)) : nameSuffix;
  return `${prefix}${kindPrefix}${suffix}`;
};
/**
 * Loads the kind entities into the store.
 *
 * @param {string} kind Kind
 *
 * @return {Array} Entities
 */


exports.getMethodName = getMethodName;

const getKindEntities = kind => async ({
  select,
  dispatch
}) => {
  let entities = select.getEntitiesByKind(kind);

  if (entities && entities.length !== 0) {
    return entities;
  }

  const kindConfig = (0, _lodash.find)(kinds, {
    name: kind
  });

  if (!kindConfig) {
    return [];
  }

  entities = await kindConfig.loadEntities();
  dispatch((0, _actions.addEntities)(entities));
  return entities;
};

exports.getKindEntities = getKindEntities;
//# sourceMappingURL=entities.js.map