{"version":3,"sources":["@wordpress/components/src/popover/utils.js"],"names":["HEIGHT_OFFSET","computePopoverXAxisPosition","anchorRect","contentSize","xAxis","corner","stickyBoundaryElement","chosenYAxis","boundaryElement","forcePosition","forceXAlignment","width","anchorMidPoint","Math","round","left","centerAlignment","popoverLeft","contentWidth","window","innerWidth","leftAlignmentX","right","rightAlignmentX","leftAlignment","rightAlignment","chosenXAxis","chosenWidth","boundaryRect","getBoundingClientRect","min","max","computePopoverYAxisPosition","yAxis","anchorRef","relativeOffsetTop","editorWrapper","height","stickyRect","stickyPositionTop","top","stickyPositionBottom","bottom","isRoomAboveInCanvas","scrollTop","popoverTop","middleAlignment","contentHeight","innerHeight","topAlignment","bottomAlignment","chosenHeight","computePopoverPosition","position","split","yAxisPosition","xAxisPosition","offsetIframe","rect","ownerDocument","container","defaultView","frameElement","iframeRect","DOMRect"],"mappings":"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","sourcesContent":["// @ts-nocheck\n/**\n * WordPress dependencies\n */\nimport { isRTL } from '@wordpress/i18n';\n\n/**\n * Module constants\n */\nconst HEIGHT_OFFSET = 10; // used by the arrow and a bit of empty space\n\n/**\n * Utility used to compute the popover position over the xAxis\n *\n * @param {Object}  anchorRect            Anchor Rect.\n * @param {Object}  contentSize           Content Size.\n * @param {string}  xAxis                 Desired xAxis.\n * @param {string}  corner                Desired corner.\n * @param {boolean} stickyBoundaryElement The boundary element to use when\n *                                        switching between sticky and normal\n *                                        position.\n * @param {string}  chosenYAxis           yAxis to be used.\n * @param {Element} boundaryElement       Boundary element.\n * @param {boolean} forcePosition         Don't adjust position based on anchor.\n * @param {boolean} forceXAlignment       Don't adjust alignment based on YAxis\n *\n * @return {Object} Popover xAxis position and constraints.\n */\nexport function computePopoverXAxisPosition(\n\tanchorRect,\n\tcontentSize,\n\txAxis,\n\tcorner,\n\tstickyBoundaryElement,\n\tchosenYAxis,\n\tboundaryElement,\n\tforcePosition,\n\tforceXAlignment\n) {\n\tconst { width } = contentSize;\n\n\t// Correct xAxis for RTL support\n\tif ( xAxis === 'left' && isRTL() ) {\n\t\txAxis = 'right';\n\t} else if ( xAxis === 'right' && isRTL() ) {\n\t\txAxis = 'left';\n\t}\n\n\tif ( corner === 'left' && isRTL() ) {\n\t\tcorner = 'right';\n\t} else if ( corner === 'right' && isRTL() ) {\n\t\tcorner = 'left';\n\t}\n\n\t// x axis alignment choices\n\tconst anchorMidPoint = Math.round( anchorRect.left + anchorRect.width / 2 );\n\tconst centerAlignment = {\n\t\tpopoverLeft: anchorMidPoint,\n\t\tcontentWidth:\n\t\t\t( anchorMidPoint - width / 2 > 0 ? width / 2 : anchorMidPoint ) +\n\t\t\t( anchorMidPoint + width / 2 > window.innerWidth\n\t\t\t\t? window.innerWidth - anchorMidPoint\n\t\t\t\t: width / 2 ),\n\t};\n\n\tlet leftAlignmentX = anchorRect.left;\n\n\tif ( corner === 'right' ) {\n\t\tleftAlignmentX = anchorRect.right;\n\t} else if ( chosenYAxis !== 'middle' && ! forceXAlignment ) {\n\t\tleftAlignmentX = anchorMidPoint;\n\t}\n\n\tlet rightAlignmentX = anchorRect.right;\n\n\tif ( corner === 'left' ) {\n\t\trightAlignmentX = anchorRect.left;\n\t} else if ( chosenYAxis !== 'middle' && ! forceXAlignment ) {\n\t\trightAlignmentX = anchorMidPoint;\n\t}\n\n\tconst leftAlignment = {\n\t\tpopoverLeft: leftAlignmentX,\n\t\tcontentWidth: leftAlignmentX - width > 0 ? width : leftAlignmentX,\n\t};\n\tconst rightAlignment = {\n\t\tpopoverLeft: rightAlignmentX,\n\t\tcontentWidth:\n\t\t\trightAlignmentX + width > window.innerWidth\n\t\t\t\t? window.innerWidth - rightAlignmentX\n\t\t\t\t: width,\n\t};\n\n\t// Choosing the x axis\n\tlet chosenXAxis = xAxis;\n\tlet contentWidth = null;\n\n\tif ( ! stickyBoundaryElement && ! forcePosition ) {\n\t\tif ( xAxis === 'center' && centerAlignment.contentWidth === width ) {\n\t\t\tchosenXAxis = 'center';\n\t\t} else if ( xAxis === 'left' && leftAlignment.contentWidth === width ) {\n\t\t\tchosenXAxis = 'left';\n\t\t} else if (\n\t\t\txAxis === 'right' &&\n\t\t\trightAlignment.contentWidth === width\n\t\t) {\n\t\t\tchosenXAxis = 'right';\n\t\t} else {\n\t\t\tchosenXAxis =\n\t\t\t\tleftAlignment.contentWidth > rightAlignment.contentWidth\n\t\t\t\t\t? 'left'\n\t\t\t\t\t: 'right';\n\t\t\tconst chosenWidth =\n\t\t\t\tchosenXAxis === 'left'\n\t\t\t\t\t? leftAlignment.contentWidth\n\t\t\t\t\t: rightAlignment.contentWidth;\n\n\t\t\t// Limit width of the content to the viewport width\n\t\t\tif ( width > window.innerWidth ) {\n\t\t\t\tcontentWidth = window.innerWidth;\n\t\t\t}\n\n\t\t\t// If we can't find any alignment options that could fit\n\t\t\t// our content, then let's fallback to the center of the viewport.\n\t\t\tif ( chosenWidth !== width ) {\n\t\t\t\tchosenXAxis = 'center';\n\t\t\t\tcenterAlignment.popoverLeft = window.innerWidth / 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet popoverLeft;\n\tif ( chosenXAxis === 'center' ) {\n\t\tpopoverLeft = centerAlignment.popoverLeft;\n\t} else if ( chosenXAxis === 'left' ) {\n\t\tpopoverLeft = leftAlignment.popoverLeft;\n\t} else {\n\t\tpopoverLeft = rightAlignment.popoverLeft;\n\t}\n\n\tif ( boundaryElement ) {\n\t\tconst boundaryRect = boundaryElement.getBoundingClientRect();\n\t\tpopoverLeft = Math.min( popoverLeft, boundaryRect.right - width );\n\n\t\t// Avoid the popover being position beyond the left boundary if the\n\t\t// direction is left to right.\n\t\tif ( ! isRTL() ) {\n\t\t\tpopoverLeft = Math.max( popoverLeft, 0 );\n\t\t}\n\t}\n\n\treturn {\n\t\txAxis: chosenXAxis,\n\t\tpopoverLeft,\n\t\tcontentWidth,\n\t};\n}\n\n/**\n * Utility used to compute the popover position over the yAxis\n *\n * @param {Object}       anchorRect            Anchor Rect.\n * @param {Object}       contentSize           Content Size.\n * @param {string}       yAxis                 Desired yAxis.\n * @param {string}       corner                Desired corner.\n * @param {boolean}      stickyBoundaryElement The boundary element to use when switching between sticky\n *                                             and normal position.\n * @param {Element}      anchorRef             The anchor element.\n * @param {Element}      relativeOffsetTop     If applicable, top offset of the relative positioned\n *                                             parent container.\n * @param {boolean}      forcePosition         Don't adjust position based on anchor.\n * @param {Element|null} editorWrapper         Element that wraps the editor content. Used to access\n *                                             scroll position to determine sticky behavior.\n * @return {Object} Popover xAxis position and constraints.\n */\nexport function computePopoverYAxisPosition(\n\tanchorRect,\n\tcontentSize,\n\tyAxis,\n\tcorner,\n\tstickyBoundaryElement,\n\tanchorRef,\n\trelativeOffsetTop,\n\tforcePosition,\n\teditorWrapper\n) {\n\tconst { height } = contentSize;\n\n\tif ( stickyBoundaryElement ) {\n\t\tconst stickyRect = stickyBoundaryElement.getBoundingClientRect();\n\t\tconst stickyPositionTop = stickyRect.top + height - relativeOffsetTop;\n\t\tconst stickyPositionBottom =\n\t\t\tstickyRect.bottom - height - relativeOffsetTop;\n\n\t\tif ( anchorRect.top <= stickyPositionTop ) {\n\t\t\tif ( editorWrapper ) {\n\t\t\t\t// If a popover cannot be positioned above the anchor, even after scrolling, we must\n\t\t\t\t// ensure we use the bottom position instead of the popover slot.  This prevents the\n\t\t\t\t// popover from always restricting block content and interaction while selected if the\n\t\t\t\t// block is near the top of the site editor.\n\n\t\t\t\tconst isRoomAboveInCanvas =\n\t\t\t\t\theight + HEIGHT_OFFSET <\n\t\t\t\t\teditorWrapper.scrollTop + anchorRect.top;\n\t\t\t\tif ( ! isRoomAboveInCanvas ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tyAxis: 'bottom',\n\t\t\t\t\t\t// If the bottom of the block is also below the bottom sticky position (ex -\n\t\t\t\t\t\t// block is also taller than the editor window), return the bottom sticky\n\t\t\t\t\t\t// position instead.  We do this instead of the top sticky position both to\n\t\t\t\t\t\t// allow a smooth transition and more importantly to ensure every section of\n\t\t\t\t\t\t// the block can be free from popover obscuration at some point in the\n\t\t\t\t\t\t// scroll position.\n\t\t\t\t\t\tpopoverTop: Math.min(\n\t\t\t\t\t\t\tanchorRect.bottom,\n\t\t\t\t\t\t\tstickyPositionBottom\n\t\t\t\t\t\t),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Default sticky behavior.\n\t\t\treturn {\n\t\t\t\tyAxis,\n\t\t\t\tpopoverTop: Math.min( anchorRect.bottom, stickyPositionTop ),\n\t\t\t};\n\t\t}\n\t}\n\n\t// y axis alignment choices\n\tlet anchorMidPoint = anchorRect.top + anchorRect.height / 2;\n\n\tif ( corner === 'bottom' ) {\n\t\tanchorMidPoint = anchorRect.bottom;\n\t} else if ( corner === 'top' ) {\n\t\tanchorMidPoint = anchorRect.top;\n\t}\n\n\tconst middleAlignment = {\n\t\tpopoverTop: anchorMidPoint,\n\t\tcontentHeight:\n\t\t\t( anchorMidPoint - height / 2 > 0 ? height / 2 : anchorMidPoint ) +\n\t\t\t( anchorMidPoint + height / 2 > window.innerHeight\n\t\t\t\t? window.innerHeight - anchorMidPoint\n\t\t\t\t: height / 2 ),\n\t};\n\n\tconst topAlignment = {\n\t\tpopoverTop: anchorRect.top,\n\t\tcontentHeight:\n\t\t\tanchorRect.top - HEIGHT_OFFSET - height > 0\n\t\t\t\t? height\n\t\t\t\t: anchorRect.top - HEIGHT_OFFSET,\n\t};\n\tconst bottomAlignment = {\n\t\tpopoverTop: anchorRect.bottom,\n\t\tcontentHeight:\n\t\t\tanchorRect.bottom + HEIGHT_OFFSET + height > window.innerHeight\n\t\t\t\t? window.innerHeight - HEIGHT_OFFSET - anchorRect.bottom\n\t\t\t\t: height,\n\t};\n\n\t// Choosing the y axis\n\tlet chosenYAxis = yAxis;\n\tlet contentHeight = null;\n\n\tif ( ! stickyBoundaryElement && ! forcePosition ) {\n\t\tif ( yAxis === 'middle' && middleAlignment.contentHeight === height ) {\n\t\t\tchosenYAxis = 'middle';\n\t\t} else if ( yAxis === 'top' && topAlignment.contentHeight === height ) {\n\t\t\tchosenYAxis = 'top';\n\t\t} else if (\n\t\t\tyAxis === 'bottom' &&\n\t\t\tbottomAlignment.contentHeight === height\n\t\t) {\n\t\t\tchosenYAxis = 'bottom';\n\t\t} else {\n\t\t\tchosenYAxis =\n\t\t\t\ttopAlignment.contentHeight > bottomAlignment.contentHeight\n\t\t\t\t\t? 'top'\n\t\t\t\t\t: 'bottom';\n\t\t\tconst chosenHeight =\n\t\t\t\tchosenYAxis === 'top'\n\t\t\t\t\t? topAlignment.contentHeight\n\t\t\t\t\t: bottomAlignment.contentHeight;\n\t\t\tcontentHeight = chosenHeight !== height ? chosenHeight : null;\n\t\t}\n\t}\n\n\tlet popoverTop;\n\tif ( chosenYAxis === 'middle' ) {\n\t\tpopoverTop = middleAlignment.popoverTop;\n\t} else if ( chosenYAxis === 'top' ) {\n\t\tpopoverTop = topAlignment.popoverTop;\n\t} else {\n\t\tpopoverTop = bottomAlignment.popoverTop;\n\t}\n\n\treturn {\n\t\tyAxis: chosenYAxis,\n\t\tpopoverTop,\n\t\tcontentHeight,\n\t};\n}\n\n/**\n * Utility used to compute the popover position and the content max width/height for a popover given\n * its anchor rect and its content size.\n *\n * @param {Object}       anchorRect            Anchor Rect.\n * @param {Object}       contentSize           Content Size.\n * @param {string}       position              Position.\n * @param {boolean}      stickyBoundaryElement The boundary element to use when switching between\n *                                             sticky and normal position.\n * @param {Element}      anchorRef             The anchor element.\n * @param {number}       relativeOffsetTop     If applicable, top offset of the relative positioned\n *                                             parent container.\n * @param {Element}      boundaryElement       Boundary element.\n * @param {boolean}      forcePosition         Don't adjust position based on anchor.\n * @param {boolean}      forceXAlignment       Don't adjust alignment based on YAxis\n * @param {Element|null} editorWrapper         Element that wraps the editor content. Used to access\n *                                             scroll position to determine sticky behavior.\n * @return {Object} Popover position and constraints.\n */\nexport function computePopoverPosition(\n\tanchorRect,\n\tcontentSize,\n\tposition = 'top',\n\tstickyBoundaryElement,\n\tanchorRef,\n\trelativeOffsetTop,\n\tboundaryElement,\n\tforcePosition,\n\tforceXAlignment,\n\teditorWrapper\n) {\n\tconst [ yAxis, xAxis = 'center', corner ] = position.split( ' ' );\n\n\tconst yAxisPosition = computePopoverYAxisPosition(\n\t\tanchorRect,\n\t\tcontentSize,\n\t\tyAxis,\n\t\tcorner,\n\t\tstickyBoundaryElement,\n\t\tanchorRef,\n\t\trelativeOffsetTop,\n\t\tforcePosition,\n\t\teditorWrapper\n\t);\n\tconst xAxisPosition = computePopoverXAxisPosition(\n\t\tanchorRect,\n\t\tcontentSize,\n\t\txAxis,\n\t\tcorner,\n\t\tstickyBoundaryElement,\n\t\tyAxisPosition.yAxis,\n\t\tboundaryElement,\n\t\tforcePosition,\n\t\tforceXAlignment\n\t);\n\n\treturn {\n\t\t...xAxisPosition,\n\t\t...yAxisPosition,\n\t};\n}\n\n/**\n * Offsets the given rect by the position of the iframe that contains the\n * element. If the owner document is not in an iframe then it returns with the\n * original rect. If the popover container document and the anchor document are\n * the same, the original rect will also be returned.\n *\n * @param {DOMRect}  rect          bounds of the element\n * @param {Document} ownerDocument document of the element\n * @param {Element}  container     The popover container to position.\n *\n * @return {DOMRect} offsetted bounds\n */\nexport function offsetIframe( rect, ownerDocument, container ) {\n\tconst { defaultView } = ownerDocument;\n\tconst { frameElement } = defaultView;\n\n\tif ( ! frameElement || ownerDocument === container.ownerDocument ) {\n\t\treturn rect;\n\t}\n\n\tconst iframeRect = frameElement.getBoundingClientRect();\n\treturn new defaultView.DOMRect(\n\t\trect.left + iframeRect.left,\n\t\trect.top + iframeRect.top,\n\t\trect.width,\n\t\trect.height\n\t);\n}\n"]}