"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _fastAverageColor = _interopRequireDefault(require("fast-average-color"));

var _colord = require("colord");

var _names = _interopRequireDefault(require("colord/plugins/names"));

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _blockEditor = require("@wordpress/block-editor");

var _i18n = require("@wordpress/i18n");

var _data = require("@wordpress/data");

var _icons = require("@wordpress/icons");

var _blob = require("@wordpress/blob");

var _shared = require("./shared");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
(0, _colord.extend)([_names.default]);
const {
  __Visualizer: BoxControlVisualizer
} = _components.__experimentalBoxControl;

function getInnerBlocksTemplate(attributes) {
  return [['core/paragraph', {
    align: 'center',
    placeholder: (0, _i18n.__)('Write titleâ€¦'),
    ...attributes
  }]];
}

function retrieveFastAverageColor() {
  if (!retrieveFastAverageColor.fastAverageColor) {
    retrieveFastAverageColor.fastAverageColor = new _fastAverageColor.default();
  }

  return retrieveFastAverageColor.fastAverageColor;
}

function CoverHeightInput({
  onChange,
  onUnitChange,
  unit = 'px',
  value = ''
}) {
  const [temporaryInput, setTemporaryInput] = (0, _element.useState)(null);
  const instanceId = (0, _compose.useInstanceId)(_blockEditor.__experimentalUnitControl);
  const inputId = `block-cover-height-input-${instanceId}`;
  const isPx = unit === 'px';
  const units = (0, _components.__experimentalUseCustomUnits)({
    availableUnits: (0, _blockEditor.useSetting)('spacing.units') || ['px', 'em', 'rem', 'vw', 'vh'],
    defaultValues: {
      px: '430',
      em: '20',
      rem: '20',
      vw: '20',
      vh: '50'
    }
  });

  const handleOnChange = unprocessedValue => {
    const inputValue = unprocessedValue !== '' ? parseInt(unprocessedValue, 10) : undefined;

    if (isNaN(inputValue) && inputValue !== undefined) {
      setTemporaryInput(unprocessedValue);
      return;
    }

    setTemporaryInput(null);
    onChange(inputValue);

    if (inputValue === undefined) {
      onUnitChange();
    }
  };

  const handleOnBlur = () => {
    if (temporaryInput !== null) {
      setTemporaryInput(null);
    }
  };

  const inputValue = temporaryInput !== null ? temporaryInput : value;
  const min = isPx ? _shared.COVER_MIN_HEIGHT : 0;
  return (0, _element.createElement)(_components.BaseControl, {
    label: (0, _i18n.__)('Minimum height of cover'),
    id: inputId
  }, (0, _element.createElement)(_blockEditor.__experimentalUnitControl, {
    id: inputId,
    isResetValueOnUnitChange: true,
    min: min,
    onBlur: handleOnBlur,
    onChange: handleOnChange,
    onUnitChange: onUnitChange,
    step: "1",
    style: {
      maxWidth: 80
    },
    unit: unit,
    units: units,
    value: inputValue
  }));
}

const RESIZABLE_BOX_ENABLE_OPTION = {
  top: false,
  right: false,
  bottom: true,
  left: false,
  topRight: false,
  bottomRight: false,
  bottomLeft: false,
  topLeft: false
};

function ResizableCover({
  className,
  onResizeStart,
  onResize,
  onResizeStop,
  ...props
}) {
  const [isResizing, setIsResizing] = (0, _element.useState)(false);
  return (0, _element.createElement)(_components.ResizableBox, (0, _extends2.default)({
    className: (0, _classnames.default)(className, {
      'is-resizing': isResizing
    }),
    enable: RESIZABLE_BOX_ENABLE_OPTION,
    onResizeStart: (_event, _direction, elt) => {
      onResizeStart(elt.clientHeight);
      onResize(elt.clientHeight);
    },
    onResize: (_event, _direction, elt) => {
      onResize(elt.clientHeight);

      if (!isResizing) {
        setIsResizing(true);
      }
    },
    onResizeStop: (_event, _direction, elt) => {
      onResizeStop(elt.clientHeight);
      setIsResizing(false);
    },
    minHeight: _shared.COVER_MIN_HEIGHT
  }, props));
}
/**
 * useCoverIsDark is a hook that returns a boolean variable specifying if the cover
 * background is dark or not.
 *
 * @param {?string} url          Url of the media background.
 * @param {?number} dimRatio     Transparency of the overlay color. If an image and
 *                               color are set, dimRatio is used to decide what is used
 *                               for background darkness checking purposes.
 * @param {?string} overlayColor String containing the overlay color value if one exists.
 * @param {?Object} elementRef   If a media background is set, elementRef should contain a reference to a
 *                               dom element that renders that media.
 *
 * @return {boolean} True if the cover background is considered "dark" and false otherwise.
 */


function useCoverIsDark(url, dimRatio = 50, overlayColor, elementRef) {
  const [isDark, setIsDark] = (0, _element.useState)(false);
  (0, _element.useEffect)(() => {
    // If opacity is lower than 50 the dominant color is the image or video color,
    // so use that color for the dark mode computation.
    if (url && dimRatio <= 50 && elementRef.current) {
      retrieveFastAverageColor().getColorAsync(elementRef.current, color => {
        setIsDark(color.isDark);
      });
    }
  }, [url, url && dimRatio <= 50 && elementRef.current, setIsDark]);
  (0, _element.useEffect)(() => {
    // If opacity is greater than 50 the dominant color is the overlay color,
    // so use that color for the dark mode computation.
    if (dimRatio > 50 || !url) {
      if (!overlayColor) {
        // If no overlay color exists the overlay color is black (isDark )
        setIsDark(true);
        return;
      }

      setIsDark((0, _colord.colord)(overlayColor).isDark());
    }
  }, [overlayColor, dimRatio > 50 || !url, setIsDark]);
  (0, _element.useEffect)(() => {
    if (!url && !overlayColor) {
      // Reset isDark
      setIsDark(false);
    }
  }, [!url && !overlayColor, setIsDark]);
  return isDark;
}

function mediaPosition({
  x,
  y
}) {
  return `${Math.round(x * 100)}% ${Math.round(y * 100)}%`;
}
/**
 * Is the URL a temporary blob URL? A blob URL is one that is used temporarily while
 * the media (image or video) is being uploaded and will not have an id allocated yet.
 *
 * @param {number} id  The id of the media.
 * @param {string} url The url of the media.
 *
 * @return {boolean} Is the URL a Blob URL.
 */


const isTemporaryMedia = (id, url) => !id && (0, _blob.isBlobURL)(url);

function CoverPlaceholder({
  disableMediaButtons = false,
  children,
  noticeUI,
  noticeOperations,
  onSelectMedia
}) {
  const {
    removeAllNotices,
    createErrorNotice
  } = noticeOperations;
  return (0, _element.createElement)(_blockEditor.MediaPlaceholder, {
    icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
      icon: _icons.cover
    }),
    labels: {
      title: (0, _i18n.__)('Cover'),
      instructions: (0, _i18n.__)('Upload an image or video file, or pick one from your media library.')
    },
    onSelect: onSelectMedia,
    accept: "image/*,video/*",
    allowedTypes: _shared.ALLOWED_MEDIA_TYPES,
    notices: noticeUI,
    disableMediaButtons: disableMediaButtons,
    onError: message => {
      removeAllNotices();
      createErrorNotice(message);
    }
  }, children);
}

function CoverEdit({
  attributes,
  clientId,
  isSelected,
  noticeUI,
  noticeOperations,
  overlayColor,
  setAttributes,
  setOverlayColor,
  toggleSelection
}) {
  var _useSetting, _styleAttribute$spaci, _styleAttribute$visua;

  const {
    contentPosition,
    id,
    backgroundType,
    dimRatio,
    focalPoint,
    hasParallax,
    isRepeated,
    minHeight,
    minHeightUnit,
    style: styleAttribute,
    url,
    alt
  } = attributes;
  const {
    gradientClass,
    gradientValue,
    setGradient
  } = (0, _blockEditor.__experimentalUseGradient)();
  const onSelectMedia = (0, _shared.attributesFromMedia)(setAttributes);
  const isUploadingMedia = isTemporaryMedia(id, url);
  const [prevMinHeightValue, setPrevMinHeightValue] = (0, _element.useState)(minHeight);
  const [prevMinHeightUnit, setPrevMinHeightUnit] = (0, _element.useState)(minHeightUnit);
  const isMinFullHeight = minHeightUnit === 'vh' && minHeight === 100;

  const toggleMinFullHeight = () => {
    if (isMinFullHeight) {
      // If there aren't previous values, take the default ones.
      if (prevMinHeightUnit === 'vh' && prevMinHeightValue === 100) {
        return setAttributes({
          minHeight: undefined,
          minHeightUnit: undefined
        });
      } // Set the previous values of height.


      return setAttributes({
        minHeight: prevMinHeightValue,
        minHeightUnit: prevMinHeightUnit
      });
    }

    setPrevMinHeightValue(minHeight);
    setPrevMinHeightUnit(minHeightUnit); // Set full height.

    return setAttributes({
      minHeight: 100,
      minHeightUnit: 'vh'
    });
  };

  const toggleParallax = () => {
    setAttributes({
      hasParallax: !hasParallax,
      ...(!hasParallax ? {
        focalPoint: undefined
      } : {})
    });
  };

  const toggleIsRepeated = () => {
    setAttributes({
      isRepeated: !isRepeated
    });
  };

  const isDarkElement = (0, _element.useRef)();
  const isDark = useCoverIsDark(url, dimRatio, overlayColor.color, isDarkElement);
  const isImageBackground = _shared.IMAGE_BACKGROUND_TYPE === backgroundType;
  const isVideoBackground = _shared.VIDEO_BACKGROUND_TYPE === backgroundType;
  const [temporaryMinHeight, setTemporaryMinHeight] = (0, _element.useState)(null);
  const minHeightWithUnit = minHeightUnit ? `${minHeight}${minHeightUnit}` : minHeight;
  const isImgElement = !(hasParallax || isRepeated);
  const style = { ...(isImageBackground && !isImgElement ? (0, _shared.backgroundImageStyles)(url) : {
      backgroundImage: gradientValue ? gradientValue : undefined
    }),
    backgroundColor: overlayColor.color,
    minHeight: temporaryMinHeight || minHeightWithUnit || undefined
  };
  const mediaStyle = {
    objectPosition: focalPoint && isImgElement ? mediaPosition(focalPoint) : undefined
  };
  const hasBackground = !!(url || overlayColor.color || gradientValue);
  const showFocalPointPicker = isVideoBackground || isImageBackground && (!hasParallax || isRepeated);

  const imperativeFocalPointPreview = value => {
    const [styleOfRef, property] = isDarkElement.current ? [isDarkElement.current.style, 'objectPosition'] : [ref.current.style, 'backgroundPosition'];
    styleOfRef[property] = mediaPosition(value);
  };

  const hasInnerBlocks = (0, _data.useSelect)(select => select(_blockEditor.store).getBlock(clientId).innerBlocks.length > 0, [clientId]);
  const controls = (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.BlockControls, {
    group: "block"
  }, (0, _element.createElement)(_blockEditor.__experimentalBlockAlignmentMatrixControl, {
    label: (0, _i18n.__)('Change content position'),
    value: contentPosition,
    onChange: nextPosition => setAttributes({
      contentPosition: nextPosition
    }),
    isDisabled: !hasInnerBlocks
  }), (0, _element.createElement)(_blockEditor.__experimentalBlockFullHeightAligmentControl, {
    isActive: isMinFullHeight,
    onToggle: toggleMinFullHeight,
    isDisabled: !hasInnerBlocks
  })), (0, _element.createElement)(_blockEditor.BlockControls, {
    group: "other"
  }, (0, _element.createElement)(_blockEditor.MediaReplaceFlow, {
    mediaId: id,
    mediaURL: url,
    allowedTypes: _shared.ALLOWED_MEDIA_TYPES,
    accept: "image/*,video/*",
    onSelect: onSelectMedia,
    name: !url ? (0, _i18n.__)('Add Media') : (0, _i18n.__)('Replace')
  })), (0, _element.createElement)(_blockEditor.InspectorControls, null, !!url && (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Media settings')
  }, isImageBackground && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Fixed background'),
    checked: hasParallax,
    onChange: toggleParallax
  }), (0, _element.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Repeated background'),
    checked: isRepeated,
    onChange: toggleIsRepeated
  })), showFocalPointPicker && (0, _element.createElement)(_components.FocalPointPicker, {
    label: (0, _i18n.__)('Focal point picker'),
    url: url,
    value: focalPoint,
    onDragStart: imperativeFocalPointPreview,
    onDrag: imperativeFocalPointPreview,
    onChange: newFocalPoint => setAttributes({
      focalPoint: newFocalPoint
    })
  }), url && isImageBackground && isImgElement && (0, _element.createElement)(_components.TextareaControl, {
    label: (0, _i18n.__)('Alt text (alternative text)'),
    value: alt,
    onChange: newAlt => setAttributes({
      alt: newAlt
    }),
    help: (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.ExternalLink, {
      href: "https://www.w3.org/WAI/tutorials/images/decision-tree"
    }, (0, _i18n.__)('Describe the purpose of the image')), (0, _i18n.__)('Leave empty if the image is purely decorative.'))
  }), (0, _element.createElement)(_components.PanelRow, null, (0, _element.createElement)(_components.Button, {
    variant: "secondary",
    isSmall: true,
    className: "block-library-cover__reset-button",
    onClick: () => setAttributes({
      url: undefined,
      id: undefined,
      backgroundType: undefined,
      dimRatio: undefined,
      focalPoint: undefined,
      hasParallax: undefined,
      isRepeated: undefined
    })
  }, (0, _i18n.__)('Clear Media')))), (0, _element.createElement)(_blockEditor.__experimentalPanelColorGradientSettings, {
    title: (0, _i18n.__)('Overlay'),
    initialOpen: true,
    settings: [{
      colorValue: overlayColor.color,
      gradientValue,
      onColorChange: setOverlayColor,
      onGradientChange: setGradient,
      label: (0, _i18n.__)('Color')
    }]
  }, !!url && (0, _element.createElement)(_components.RangeControl, {
    label: (0, _i18n.__)('Opacity'),
    value: dimRatio,
    onChange: newDimRation => setAttributes({
      dimRatio: newDimRation
    }),
    min: 0,
    max: 100,
    step: 10,
    required: true
  }))), (0, _element.createElement)(_blockEditor.InspectorControls, {
    __experimentalGroup: "dimensions"
  }, (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    hasValue: () => !!minHeight,
    label: (0, _i18n.__)('Minimum height'),
    onDeselect: () => setAttributes({
      minHeight: undefined,
      minHeightUnit: undefined
    }),
    resetAllFilter: () => ({
      minHeight: undefined,
      minHeightUnit: undefined
    }),
    isShownByDefault: true,
    panelId: clientId
  }, (0, _element.createElement)(CoverHeightInput, {
    value: temporaryMinHeight || minHeight,
    unit: minHeightUnit,
    onChange: newMinHeight => setAttributes({
      minHeight: newMinHeight
    }),
    onUnitChange: nextUnit => setAttributes({
      minHeightUnit: nextUnit
    })
  }))));
  const ref = (0, _element.useRef)();
  const blockProps = (0, _blockEditor.useBlockProps)({
    ref
  }); // Check for fontSize support before we pass a fontSize attribute to the innerBlocks.

  const hasFontSizes = !!((_useSetting = (0, _blockEditor.useSetting)('typography.fontSizes')) !== null && _useSetting !== void 0 && _useSetting.length);
  const innerBlocksTemplate = getInnerBlocksTemplate({
    fontSize: hasFontSizes ? 'large' : undefined
  });
  const innerBlocksProps = (0, _blockEditor.__experimentalUseInnerBlocksProps)({
    className: 'wp-block-cover__inner-container'
  }, {
    template: innerBlocksTemplate,
    templateInsertUpdatesSelection: true
  });

  if (!hasInnerBlocks && !hasBackground) {
    return (0, _element.createElement)(_element.Fragment, null, controls, (0, _element.createElement)("div", (0, _extends2.default)({}, blockProps, {
      className: (0, _classnames.default)('is-placeholder', blockProps.className)
    }), (0, _element.createElement)(CoverPlaceholder, {
      noticeUI: noticeUI,
      onSelectMedia: onSelectMedia,
      noticeOperations: noticeOperations
    }, (0, _element.createElement)("div", {
      className: "wp-block-cover__placeholder-background-options"
    }, (0, _element.createElement)(_blockEditor.ColorPalette, {
      disableCustomColors: true,
      value: overlayColor.color,
      onChange: setOverlayColor,
      clearable: false
    })))));
  }

  const classes = (0, _classnames.default)((0, _shared.dimRatioToClass)(dimRatio), {
    'is-dark-theme': isDark,
    'has-background-dim': dimRatio !== 0,
    'is-transient': isUploadingMedia,
    'has-parallax': hasParallax,
    'is-repeated': isRepeated,
    [overlayColor.class]: overlayColor.class,
    'has-background-gradient': gradientValue,
    [gradientClass]: !url && gradientClass,
    'has-custom-content-position': !(0, _shared.isContentPositionCenter)(contentPosition)
  }, (0, _shared.getPositionClassName)(contentPosition));
  return (0, _element.createElement)(_element.Fragment, null, controls, (0, _element.createElement)("div", (0, _extends2.default)({}, blockProps, {
    className: (0, _classnames.default)(classes, blockProps.className),
    style: { ...style,
      ...blockProps.style
    },
    "data-url": url
  }), (0, _element.createElement)(BoxControlVisualizer, {
    values: styleAttribute === null || styleAttribute === void 0 ? void 0 : (_styleAttribute$spaci = styleAttribute.spacing) === null || _styleAttribute$spaci === void 0 ? void 0 : _styleAttribute$spaci.padding,
    showValues: styleAttribute === null || styleAttribute === void 0 ? void 0 : (_styleAttribute$visua = styleAttribute.visualizers) === null || _styleAttribute$visua === void 0 ? void 0 : _styleAttribute$visua.padding
  }), (0, _element.createElement)(ResizableCover, {
    className: "block-library-cover__resize-container",
    onResizeStart: () => {
      setAttributes({
        minHeightUnit: 'px'
      });
      toggleSelection(false);
    },
    onResize: setTemporaryMinHeight,
    onResizeStop: newMinHeight => {
      toggleSelection(true);
      setAttributes({
        minHeight: newMinHeight
      });
      setTemporaryMinHeight(null);
    },
    showHandle: isSelected
  }), url && gradientValue && dimRatio !== 0 && (0, _element.createElement)("span", {
    "aria-hidden": "true",
    className: (0, _classnames.default)('wp-block-cover__gradient-background', gradientClass),
    style: {
      backgroundImage: gradientValue
    }
  }), url && isImageBackground && isImgElement && (0, _element.createElement)("img", {
    ref: isDarkElement,
    className: "wp-block-cover__image-background",
    alt: alt,
    src: url,
    style: mediaStyle
  }), url && isVideoBackground && (0, _element.createElement)("video", {
    ref: isDarkElement,
    className: "wp-block-cover__video-background",
    autoPlay: true,
    muted: true,
    loop: true,
    src: url,
    style: mediaStyle
  }), isUploadingMedia && (0, _element.createElement)(_components.Spinner, null), (0, _element.createElement)(CoverPlaceholder, {
    disableMediaButtons: true,
    noticeUI: noticeUI,
    onSelectMedia: onSelectMedia,
    noticeOperations: noticeOperations
  }), (0, _element.createElement)("div", innerBlocksProps)));
}

var _default = (0, _compose.compose)([(0, _data.withDispatch)(dispatch => {
  const {
    toggleSelection
  } = dispatch(_blockEditor.store);
  return {
    toggleSelection
  };
}), (0, _blockEditor.withColors)({
  overlayColor: 'background-color'
}), _components.withNotices, _compose.withInstanceId])(CoverEdit);

exports.default = _default;
//# sourceMappingURL=edit.js.map