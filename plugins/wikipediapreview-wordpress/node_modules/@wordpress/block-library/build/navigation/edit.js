"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _blockEditor = require("@wordpress/block-editor");

var _data = require("@wordpress/data");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _i18n = require("@wordpress/i18n");

var _useBlockNavigator = _interopRequireDefault(require("./use-block-navigator"));

var _placeholder = _interopRequireDefault(require("./placeholder"));

var _placeholderPreview = _interopRequireDefault(require("./placeholder-preview"));

var _responsiveWrapper = _interopRequireDefault(require("./responsive-wrapper"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const ALLOWED_BLOCKS = ['core/navigation-link', 'core/search', 'core/social-links', 'core/page-list', 'core/spacer', 'core/home-link', 'core/site-title', 'core/site-logo', 'core/navigation-submenu'];
const DEFAULT_BLOCK = ['core/navigation-link'];

const DIRECT_INSERT = block => {
  return block.innerBlocks.every(({
    name
  }) => name === 'core/navigation-link' || name === 'core/navigation-submenu');
};

const LAYOUT = {
  type: 'default',
  alignments: []
};

function getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}

function detectColors(colorsDetectionElement, setColor, setBackground) {
  if (!colorsDetectionElement) {
    return;
  }

  setColor(getComputedStyle(colorsDetectionElement).color);
  let backgroundColorNode = colorsDetectionElement;
  let backgroundColor = getComputedStyle(backgroundColorNode).backgroundColor;

  while (backgroundColor === 'rgba(0, 0, 0, 0)' && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
    backgroundColorNode = backgroundColorNode.parentNode;
    backgroundColor = getComputedStyle(backgroundColorNode).backgroundColor;
  }

  setBackground(backgroundColor);
}

function Navigation({
  selectedBlockHasDescendants,
  attributes,
  setAttributes,
  clientId,
  hasExistingNavItems,
  isImmediateParentOfSelectedBlock,
  isSelected,
  updateInnerBlocks,
  className,
  backgroundColor,
  setBackgroundColor,
  textColor,
  setTextColor,
  overlayBackgroundColor,
  setOverlayBackgroundColor,
  overlayTextColor,
  setOverlayTextColor,
  // These props are used by the navigation editor to override specific
  // navigation block settings.
  hasSubmenuIndicatorSetting = true,
  hasItemJustificationControls = true,
  hasColorSettings = true,
  customPlaceholder: CustomPlaceholder = null,
  customAppender: CustomAppender = null
}) {
  const [isPlaceholderShown, setIsPlaceholderShown] = (0, _element.useState)(!hasExistingNavItems);
  const [isResponsiveMenuOpen, setResponsiveMenuVisibility] = (0, _element.useState)(false);
  const {
    selectBlock
  } = (0, _data.useDispatch)(_blockEditor.store);
  const navRef = (0, _element.useRef)();
  const blockProps = (0, _blockEditor.useBlockProps)({
    ref: navRef,
    className: (0, _classnames.default)(className, {
      [`items-justified-${attributes.itemsJustification}`]: attributes.itemsJustification,
      'is-vertical': attributes.orientation === 'vertical',
      'is-responsive': attributes.isResponsive,
      'has-text-color': !!textColor.color || !!(textColor !== null && textColor !== void 0 && textColor.class),
      [(0, _blockEditor.getColorClassName)('color', textColor === null || textColor === void 0 ? void 0 : textColor.slug)]: !!(textColor !== null && textColor !== void 0 && textColor.slug),
      'has-background': !!backgroundColor.color || backgroundColor.class,
      [(0, _blockEditor.getColorClassName)('background-color', backgroundColor === null || backgroundColor === void 0 ? void 0 : backgroundColor.slug)]: !!(backgroundColor !== null && backgroundColor !== void 0 && backgroundColor.slug)
    }),
    style: {
      color: !(textColor !== null && textColor !== void 0 && textColor.slug) && (textColor === null || textColor === void 0 ? void 0 : textColor.color),
      backgroundColor: !(backgroundColor !== null && backgroundColor !== void 0 && backgroundColor.slug) && (backgroundColor === null || backgroundColor === void 0 ? void 0 : backgroundColor.color)
    }
  });
  const {
    navigatorToolbarButton,
    navigatorModal
  } = (0, _useBlockNavigator.default)(clientId);
  const placeholder = (0, _element.useMemo)(() => (0, _element.createElement)(_placeholderPreview.default, null), []); // When the block is selected itself or has a top level item selected that
  // doesn't itself have children, show the standard appender. Else show no
  // appender.

  const appender = isSelected || isImmediateParentOfSelectedBlock && !selectedBlockHasDescendants ? undefined : false;
  const innerBlocksProps = (0, _blockEditor.__experimentalUseInnerBlocksProps)({
    className: 'wp-block-navigation__container'
  }, {
    allowedBlocks: ALLOWED_BLOCKS,
    __experimentalDefaultBlock: DEFAULT_BLOCK,
    __experimentalDirectInsert: DIRECT_INSERT,
    orientation: attributes.orientation,
    renderAppender: CustomAppender || appender,
    // Ensure block toolbar is not too far removed from item
    // being edited when in vertical mode.
    // see: https://github.com/WordPress/gutenberg/pull/34615.
    __experimentalCaptureToolbars: attributes.orientation !== 'vertical',
    // Template lock set to false here so that the Nav
    // Block on the experimental menus screen does not
    // inherit templateLock={ 'all' }.
    templateLock: false,
    __experimentalLayout: LAYOUT,
    placeholder: !CustomPlaceholder ? placeholder : undefined
  }); // Turn on contrast checker for web only since it's not supported on mobile yet.

  const enableContrastChecking = _element.Platform.OS === 'web';
  const [detectedBackgroundColor, setDetectedBackgroundColor] = (0, _element.useState)();
  const [detectedColor, setDetectedColor] = (0, _element.useState)();
  const [detectedOverlayBackgroundColor, setDetectedOverlayBackgroundColor] = (0, _element.useState)();
  const [detectedOverlayColor, setDetectedOverlayColor] = (0, _element.useState)();
  (0, _element.useEffect)(() => {
    if (!enableContrastChecking) {
      return;
    }

    detectColors(navRef.current, setDetectedColor, setDetectedBackgroundColor);
    const subMenuElement = navRef.current.querySelector('[data-type="core/navigation-link"] [data-type="core/navigation-link"]');

    if (subMenuElement) {
      detectColors(subMenuElement, setDetectedOverlayColor, setDetectedOverlayBackgroundColor);
    }
  });

  if (isPlaceholderShown) {
    const PlaceholderComponent = CustomPlaceholder ? CustomPlaceholder : _placeholder.default;
    return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(PlaceholderComponent, {
      onCreate: (blocks, selectNavigationBlock) => {
        setIsPlaceholderShown(false);
        updateInnerBlocks(blocks);

        if (selectNavigationBlock) {
          selectBlock(clientId);
        }
      }
    }));
  }

  const justifyAllowedControls = attributes.orientation === 'vertical' ? ['left', 'center', 'right'] : ['left', 'center', 'right', 'space-between'];
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.BlockControls, null, hasItemJustificationControls && (0, _element.createElement)(_blockEditor.JustifyToolbar, {
    value: attributes.itemsJustification,
    allowedControls: justifyAllowedControls,
    onChange: value => setAttributes({
      itemsJustification: value
    }),
    popoverProps: {
      position: 'bottom right',
      isAlternate: true
    }
  }), (0, _element.createElement)(_components.ToolbarGroup, null, navigatorToolbarButton)), navigatorModal, (0, _element.createElement)(_blockEditor.InspectorControls, null, hasSubmenuIndicatorSetting && (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Display settings')
  }, (0, _element.createElement)(_components.ToggleControl, {
    checked: attributes.isResponsive,
    onChange: value => {
      setAttributes({
        isResponsive: value
      });
    },
    label: (0, _i18n.__)('Enable responsive menu')
  }), (0, _element.createElement)(_components.ToggleControl, {
    checked: attributes.openSubmenusOnClick,
    onChange: value => {
      setAttributes({
        openSubmenusOnClick: value
      });
    },
    label: (0, _i18n.__)('Open submenus on click')
  }), !attributes.openSubmenusOnClick && (0, _element.createElement)(_components.ToggleControl, {
    checked: attributes.showSubmenuIcon,
    onChange: value => {
      setAttributes({
        showSubmenuIcon: value
      });
    },
    label: (0, _i18n.__)('Show submenu indicator icons')
  })), hasColorSettings && (0, _element.createElement)(_blockEditor.PanelColorSettings, {
    title: (0, _i18n.__)('Color'),
    initialOpen: false,
    colorSettings: [{
      value: textColor.color,
      onChange: setTextColor,
      label: (0, _i18n.__)('Text')
    }, {
      value: backgroundColor.color,
      onChange: setBackgroundColor,
      label: (0, _i18n.__)('Background')
    }, {
      value: overlayTextColor.color,
      onChange: setOverlayTextColor,
      label: (0, _i18n.__)('Overlay text')
    }, {
      value: overlayBackgroundColor.color,
      onChange: setOverlayBackgroundColor,
      label: (0, _i18n.__)('Overlay background')
    }]
  }, enableContrastChecking && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.ContrastChecker, {
    backgroundColor: detectedBackgroundColor,
    textColor: detectedColor
  }), (0, _element.createElement)(_blockEditor.ContrastChecker, {
    backgroundColor: detectedOverlayBackgroundColor,
    textColor: detectedOverlayColor
  })))), (0, _element.createElement)("nav", blockProps, (0, _element.createElement)(_responsiveWrapper.default, {
    id: clientId,
    onToggle: setResponsiveMenuVisibility,
    isOpen: isResponsiveMenuOpen,
    isResponsive: attributes.isResponsive
  }, (0, _element.createElement)("div", innerBlocksProps))));
}

var _default = (0, _compose.compose)([(0, _data.withSelect)((select, {
  clientId
}) => {
  var _getClientIdsOfDescen;

  const innerBlocks = select(_blockEditor.store).getBlocks(clientId);
  const {
    getClientIdsOfDescendants,
    hasSelectedInnerBlock,
    getSelectedBlockClientId
  } = select(_blockEditor.store);
  const isImmediateParentOfSelectedBlock = hasSelectedInnerBlock(clientId, false);
  const selectedBlockId = getSelectedBlockClientId();
  const selectedBlockHasDescendants = !!((_getClientIdsOfDescen = getClientIdsOfDescendants([selectedBlockId])) !== null && _getClientIdsOfDescen !== void 0 && _getClientIdsOfDescen.length);
  return {
    isImmediateParentOfSelectedBlock,
    selectedBlockHasDescendants,
    hasExistingNavItems: !!innerBlocks.length,
    // This prop is already available but computing it here ensures it's
    // fresh compared to isImmediateParentOfSelectedBlock
    isSelected: selectedBlockId === clientId
  };
}), (0, _data.withDispatch)((dispatch, {
  clientId
}) => {
  return {
    updateInnerBlocks(blocks) {
      if ((blocks === null || blocks === void 0 ? void 0 : blocks.length) === 0) {
        return false;
      }

      dispatch(_blockEditor.store).replaceInnerBlocks(clientId, blocks, true);
    }

  };
}), (0, _blockEditor.withColors)({
  textColor: 'color'
}, {
  backgroundColor: 'color'
}, {
  overlayBackgroundColor: 'color'
}, {
  overlayTextColor: 'color'
})])(Navigation);

exports.default = _default;
//# sourceMappingURL=edit.js.map