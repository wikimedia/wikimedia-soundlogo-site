"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ImageEdit = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactNative = require("react-native");

var _reactNativeBridge = require("@wordpress/react-native-bridge");

var _components = require("@wordpress/components");

var _blockEditor = require("@wordpress/block-editor");

var _i18n = require("@wordpress/i18n");

var _url = require("@wordpress/url");

var _hooks = require("@wordpress/hooks");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _icons = require("@wordpress/icons");

var _coreData = require("@wordpress/core-data");

var _editPost = require("@wordpress/edit-post");

var _styles = _interopRequireDefault(require("./styles.scss"));

var _utils = require("./utils");

var _constants = require("./constants");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const getUrlForSlug = (image, sizeSlug) => {
  var _image$media_details, _image$media_details$, _image$media_details$2;

  if (!sizeSlug) {
    return undefined;
  }

  return image === null || image === void 0 ? void 0 : (_image$media_details = image.media_details) === null || _image$media_details === void 0 ? void 0 : (_image$media_details$ = _image$media_details.sizes) === null || _image$media_details$ === void 0 ? void 0 : (_image$media_details$2 = _image$media_details$[sizeSlug]) === null || _image$media_details$2 === void 0 ? void 0 : _image$media_details$2.source_url;
};

class ImageEdit extends _element.Component {
  constructor(props) {
    super(props);
    this.state = {
      isCaptionSelected: false
    };
    this.finishMediaUploadWithSuccess = this.finishMediaUploadWithSuccess.bind(this);
    this.finishMediaUploadWithFailure = this.finishMediaUploadWithFailure.bind(this);
    this.mediaUploadStateReset = this.mediaUploadStateReset.bind(this);
    this.onSelectMediaUploadOption = this.onSelectMediaUploadOption.bind(this);
    this.updateMediaProgress = this.updateMediaProgress.bind(this);
    this.updateImageURL = this.updateImageURL.bind(this);
    this.onSetLinkDestination = this.onSetLinkDestination.bind(this);
    this.onSetNewTab = this.onSetNewTab.bind(this);
    this.onSetSizeSlug = this.onSetSizeSlug.bind(this);
    this.onImagePressed = this.onImagePressed.bind(this);
    this.onSetFeatured = this.onSetFeatured.bind(this);
    this.onFocusCaption = this.onFocusCaption.bind(this);
    this.updateAlignment = this.updateAlignment.bind(this);
    this.accessibilityLabelCreator = this.accessibilityLabelCreator.bind(this);
    this.setMappedAttributes = this.setMappedAttributes.bind(this);
    this.onSizeChangeValue = this.onSizeChangeValue.bind(this);
    this.linkSettingsOptions = {
      url: {
        label: (0, _i18n.__)('Image Link URL'),
        placeholder: (0, _i18n.__)('Add URL'),
        autoFocus: false,
        autoFill: true
      },
      openInNewTab: {
        label: (0, _i18n.__)('Open in new tab')
      },
      linkRel: {
        label: (0, _i18n.__)('Link Rel'),
        placeholder: (0, _i18n._x)('None', 'Link rel attribute value placeholder')
      }
    };
  }

  componentDidMount() {
    const {
      attributes,
      setAttributes
    } = this.props; // This will warn when we have `id` defined, while `url` is undefined.
    // This may help track this issue: https://github.com/wordpress-mobile/WordPress-Android/issues/9768
    // where a cancelled image upload was resulting in a subsequent crash.

    if (attributes.id && !attributes.url) {
      // eslint-disable-next-line no-console
      console.warn('Attributes has id with no url.');
    } // Detect any pasted image and start an upload


    if (!attributes.id && attributes.url && (0, _url.getProtocol)(attributes.url) === 'file:') {
      (0, _reactNativeBridge.requestMediaImport)(attributes.url, (id, url) => {
        if (url) {
          setAttributes({
            id,
            url
          });
        }
      });
    } // Make sure we mark any temporary images as failed if they failed while
    // the editor wasn't open


    if (attributes.id && attributes.url && (0, _url.getProtocol)(attributes.url) === 'file:') {
      (0, _reactNativeBridge.mediaUploadSync)();
    }
  }

  componentWillUnmount() {
    // this action will only exist if the user pressed the trash button on the block holder
    if ((0, _hooks.hasAction)('blocks.onRemoveBlockCheckUpload') && this.state.isUploadInProgress) {
      (0, _hooks.doAction)('blocks.onRemoveBlockCheckUpload', this.props.attributes.id);
    }
  }

  componentDidUpdate(previousProps) {
    const {
      image,
      attributes,
      setAttributes
    } = this.props;

    if (!previousProps.image && image) {
      const url = getUrlForSlug(image, attributes === null || attributes === void 0 ? void 0 : attributes.sizeSlug) || image.source_url;
      setAttributes({
        url
      });
    }
  }

  static getDerivedStateFromProps(props, state) {
    // Avoid a UI flicker in the toolbar by insuring that isCaptionSelected
    // is updated immediately any time the isSelected prop becomes false
    return {
      isCaptionSelected: props.isSelected && state.isCaptionSelected
    };
  }

  accessibilityLabelCreator(caption) {
    // Checks if caption is empty.
    return typeof caption === 'string' && caption.trim().length === 0 || caption === undefined || caption === null ?
    /* translators: accessibility text. Empty image caption. */
    'Image caption. Empty' : (0, _i18n.sprintf)(
    /* translators: accessibility text. %s: image caption. */
    (0, _i18n.__)('Image caption. %s'), caption);
  }

  onImagePressed() {
    const {
      attributes,
      image
    } = this.props;

    if (this.state.isUploadInProgress) {
      (0, _reactNativeBridge.requestImageUploadCancelDialog)(attributes.id);
    } else if (attributes.id && (0, _url.getProtocol)(attributes.url) === 'file:') {
      (0, _reactNativeBridge.requestImageFailedRetryDialog)(attributes.id);
    } else if (!this.state.isCaptionSelected) {
      (0, _reactNativeBridge.requestImageFullscreenPreview)(attributes.url, image && image.source_url);
    }

    this.setState({
      isCaptionSelected: false
    });
  }

  updateMediaProgress(payload) {
    const {
      setAttributes
    } = this.props;

    if (payload.mediaUrl) {
      setAttributes({
        url: payload.mediaUrl
      });
    }

    if (!this.state.isUploadInProgress) {
      this.setState({
        isUploadInProgress: true
      });
    }
  }

  finishMediaUploadWithSuccess(payload) {
    const {
      setAttributes
    } = this.props;
    setAttributes({
      url: payload.mediaUrl,
      id: payload.mediaServerId
    });
    this.setState({
      isUploadInProgress: false
    });
  }

  finishMediaUploadWithFailure(payload) {
    const {
      setAttributes
    } = this.props;
    setAttributes({
      id: payload.mediaId
    });
    this.setState({
      isUploadInProgress: false
    });
  }

  mediaUploadStateReset() {
    const {
      setAttributes
    } = this.props;
    setAttributes({
      id: null,
      url: null
    });
    this.setState({
      isUploadInProgress: false
    });
  }

  updateImageURL(url) {
    this.props.setAttributes({
      url,
      width: undefined,
      height: undefined
    });
  }

  updateAlignment(nextAlign) {
    const extraUpdatedAttributes = Object.values(_components.WIDE_ALIGNMENTS.alignments).includes(nextAlign) ? {
      width: undefined,
      height: undefined
    } : {};
    this.props.setAttributes({ ...extraUpdatedAttributes,
      align: nextAlign
    });
  }

  onSetLinkDestination(href) {
    this.props.setAttributes({
      linkDestination: _constants.LINK_DESTINATION_CUSTOM,
      href
    });
  }

  onSetNewTab(value) {
    const updatedLinkTarget = (0, _utils.getUpdatedLinkTargetSettings)(value, this.props.attributes);
    this.props.setAttributes(updatedLinkTarget);
  }

  onSetSizeSlug(sizeSlug) {
    const {
      image,
      setAttributes
    } = this.props;
    const url = getUrlForSlug(image, sizeSlug);

    if (!url) {
      return null;
    }

    setAttributes({
      url,
      width: undefined,
      height: undefined,
      sizeSlug
    });
  }

  onSelectMediaUploadOption(media) {
    const {
      imageDefaultSize
    } = this.props;
    const {
      id,
      url,
      destination
    } = this.props.attributes;
    const mediaAttributes = {
      id: media.id,
      url: media.url,
      caption: media.caption
    };
    let additionalAttributes; // Reset the dimension attributes if changing to a different image.

    if (!media.id || media.id !== id) {
      additionalAttributes = {
        width: undefined,
        height: undefined,
        sizeSlug: imageDefaultSize
      };
    } else {
      // Keep the same url when selecting the same file, so "Image Size" option is not changed.
      additionalAttributes = {
        url
      };
    }

    let href;

    switch (destination) {
      case _constants.LINK_DESTINATION_MEDIA:
        href = media.url;
        break;

      case _constants.LINK_DESTINATION_ATTACHMENT:
        href = media.link;
        break;
    }

    mediaAttributes.href = href;
    this.props.setAttributes({ ...mediaAttributes,
      ...additionalAttributes
    });
  }

  onFocusCaption() {
    if (this.props.onFocus) {
      this.props.onFocus();
    }

    if (!this.state.isCaptionSelected) {
      this.setState({
        isCaptionSelected: true
      });
    }
  }

  getPlaceholderIcon() {
    return (0, _element.createElement)(_components.Icon, (0, _extends2.default)({
      icon: _icons.image
    }, this.props.getStylesFromColorScheme(_styles.default.iconPlaceholder, _styles.default.iconPlaceholderDark)));
  }

  getWidth() {
    const {
      attributes
    } = this.props;
    const {
      align,
      width
    } = attributes;
    return Object.values(_components.WIDE_ALIGNMENTS.alignments).includes(align) ? '100%' : width;
  }

  setMappedAttributes({
    url: href,
    ...restAttributes
  }) {
    const {
      setAttributes
    } = this.props;
    return href === undefined ? setAttributes({ ...restAttributes,
      linkDestination: _constants.LINK_DESTINATION_CUSTOM
    }) : setAttributes({ ...restAttributes,
      href,
      linkDestination: _constants.LINK_DESTINATION_CUSTOM
    });
  }

  getLinkSettings() {
    const {
      isLinkSheetVisible
    } = this.state;
    const {
      attributes: {
        href: url,
        ...unMappedAttributes
      }
    } = this.props;
    const mappedAttributes = { ...unMappedAttributes,
      url
    };
    return (0, _element.createElement)(_components.LinkSettingsNavigation, {
      isVisible: isLinkSheetVisible,
      url: mappedAttributes.url,
      rel: mappedAttributes.rel,
      label: mappedAttributes.label,
      linkTarget: mappedAttributes.linkTarget,
      onClose: this.dismissSheet,
      setAttributes: this.setMappedAttributes,
      withBottomSheet: false,
      hasPicker: true,
      options: this.linkSettingsOptions,
      showIcon: false
    });
  }

  getAltTextSettings() {
    const {
      attributes: {
        alt
      }
    } = this.props;

    const updateAlt = newAlt => {
      this.props.setAttributes({
        alt: newAlt
      });
    };

    return (0, _element.createElement)(_components.BottomSheetTextControl, {
      initialValue: alt,
      onChange: updateAlt,
      placeholder: (0, _i18n.__)('Add alt text'),
      label: (0, _i18n.__)('Alt Text'),
      icon: _icons.textColor,
      footerNote: (0, _element.createElement)(_element.Fragment, null, (0, _i18n.__)('Describe the purpose of the image. Leave empty if the image is purely decorative. '), (0, _element.createElement)(_components.FooterMessageLink, {
        href: 'https://www.w3.org/WAI/tutorials/images/decision-tree/',
        value: (0, _i18n.__)('What is alt text?')
      }))
    });
  }

  onSizeChangeValue(newValue) {
    this.onSetSizeSlug(newValue);
  }

  onSetFeatured(mediaId) {
    const {
      closeSettingsBottomSheet
    } = this.props;
    (0, _reactNativeBridge.setFeaturedImage)(mediaId);
    closeSettingsBottomSheet();
  }

  getFeaturedButtonPanel(isFeaturedImage) {
    const {
      attributes,
      getStylesFromColorScheme
    } = this.props;
    const setFeaturedButtonStyle = getStylesFromColorScheme(_styles.default.setFeaturedButton, _styles.default.setFeaturedButtonDark);

    const removeFeaturedButton = () => (0, _element.createElement)(_components.BottomSheet.Cell, {
      label: (0, _i18n.__)('Remove as Featured Image '),
      labelStyle: [setFeaturedButtonStyle, _styles.default.removeFeaturedButton],
      cellContainerStyle: _styles.default.setFeaturedButtonCellContainer,
      separatorType: 'none',
      onPress: () => this.onSetFeatured(_constants.MEDIA_ID_NO_FEATURED_IMAGE_SET)
    });

    const setFeaturedButton = () => (0, _element.createElement)(_components.BottomSheet.Cell, {
      label: (0, _i18n.__)('Set as Featured Image '),
      labelStyle: setFeaturedButtonStyle,
      cellContainerStyle: _styles.default.setFeaturedButtonCellContainer,
      separatorType: 'none',
      onPress: () => this.onSetFeatured(attributes.id)
    });

    return isFeaturedImage ? removeFeaturedButton() : setFeaturedButton();
  }

  render() {
    const {
      isCaptionSelected
    } = this.state;
    const {
      attributes,
      isSelected,
      image,
      clientId,
      imageDefaultSize,
      context,
      featuredImageId,
      wasBlockJustInserted
    } = this.props;
    const {
      align,
      url,
      alt,
      id,
      sizeSlug,
      className
    } = attributes;
    const hasImageContext = context ? Object.keys(context).length > 0 : false;
    const imageSizes = Array.isArray(this.props.imageSizes) ? this.props.imageSizes : []; // Only map available image sizes for the user to choose.

    const sizeOptions = imageSizes.filter(({
      slug
    }) => getUrlForSlug(image, slug)).map(({
      name,
      slug
    }) => ({
      value: slug,
      label: name
    }));
    let selectedSizeOption = sizeSlug || imageDefaultSize;
    let sizeOptionsValid = sizeOptions.find(option => option.value === selectedSizeOption);

    if (!sizeOptionsValid) {
      // Default to 'full' size if the default large size is not available.
      sizeOptionsValid = sizeOptions.find(option => option.value === 'full');
      selectedSizeOption = 'full';
    } // By default, it's only possible to set images that have been uploaded to a site's library as featured.
    // The 'canImageBeFeatured' check filters out images that haven't been uploaded based on the following:
    // - Images that are embedded in a post but are uploaded elsewhere have an id of 'undefined'.
    // - Image that are uploading or have failed to upload are given a temporary negative ID.


    const canImageBeFeatured = typeof attributes.id !== 'undefined' && attributes.id > 0;
    const isFeaturedImage = canImageBeFeatured && featuredImageId === attributes.id;

    const getToolbarEditButton = open => (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_components.ToolbarGroup, null, (0, _element.createElement)(_components.ToolbarButton, {
      title: (0, _i18n.__)('Edit image'),
      icon: _icons.replace,
      onClick: open
    })), (0, _element.createElement)(_blockEditor.BlockAlignmentToolbar, {
      value: align,
      onChange: this.updateAlignment
    }));

    const getInspectorControls = () => (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
      title: (0, _i18n.__)('Image settings')
    }), (0, _element.createElement)(_components.PanelBody, {
      style: _styles.default.panelBody
    }, (0, _element.createElement)(_blockEditor.BlockStyles, {
      clientId: clientId,
      url: url
    })), (0, _element.createElement)(_components.PanelBody, null, image && sizeOptionsValid && (0, _element.createElement)(_components.BottomSheetSelectControl, {
      icon: _icons.fullscreen,
      label: (0, _i18n.__)('Size'),
      options: sizeOptions,
      onChange: this.onSizeChangeValue,
      value: selectedSizeOption
    }), this.getAltTextSettings()), (0, _element.createElement)(_components.PanelBody, {
      title: (0, _i18n.__)('Link Settings')
    }, this.getLinkSettings(true)), (0, _element.createElement)(_components.PanelBody, {
      title: (0, _i18n.__)('Featured Image'),
      titleStyle: _styles.default.featuredImagePanelTitle
    }, canImageBeFeatured && this.getFeaturedButtonPanel(isFeaturedImage), (0, _element.createElement)(_components.FooterMessageControl, {
      label: (0, _i18n.__)('Changes to featured image will not be affected by the undo/redo buttons.'),
      cellContainerStyle: _styles.default.setFeaturedButtonCellContainer
    })));

    if (!url) {
      return (0, _element.createElement)(_reactNative.View, {
        style: _styles.default.content
      }, (0, _element.createElement)(_blockEditor.MediaPlaceholder, {
        allowedTypes: [_blockEditor.MEDIA_TYPE_IMAGE],
        onSelect: this.onSelectMediaUploadOption,
        icon: this.getPlaceholderIcon(),
        onFocus: this.props.onFocus,
        autoOpenMediaUpload: isSelected && wasBlockJustInserted
      }));
    }

    const alignToFlex = {
      left: 'flex-start',
      center: 'center',
      right: 'flex-end',
      full: 'center',
      wide: 'center'
    };
    const additionalImageProps = {
      height: '100%',
      resizeMode: context !== null && context !== void 0 && context.imageCrop ? 'cover' : 'contain'
    };
    const imageContainerStyles = [hasImageContext && _styles.default.fixedHeight];

    const getImageComponent = (openMediaOptions, getMediaOptions) => (0, _element.createElement)(_components.Badge, {
      label: (0, _i18n.__)('Featured'),
      show: isFeaturedImage
    }, (0, _element.createElement)(_reactNative.TouchableWithoutFeedback, {
      accessible: !isSelected,
      onPress: this.onImagePressed,
      onLongPress: openMediaOptions,
      disabled: !isSelected
    }, (0, _element.createElement)(_reactNative.View, {
      style: _styles.default.content
    }, isSelected && getInspectorControls(), isSelected && getMediaOptions(), !this.state.isCaptionSelected && getToolbarEditButton(openMediaOptions), (0, _element.createElement)(_blockEditor.MediaUploadProgress, {
      coverUrl: url,
      mediaId: id,
      onUpdateMediaProgress: this.updateMediaProgress,
      onFinishMediaUploadWithSuccess: this.finishMediaUploadWithSuccess,
      onFinishMediaUploadWithFailure: this.finishMediaUploadWithFailure,
      onMediaUploadStateReset: this.mediaUploadStateReset,
      renderContent: ({
        isUploadInProgress,
        isUploadFailed,
        retryMessage
      }) => {
        return (0, _element.createElement)(_reactNative.View, {
          style: imageContainerStyles
        }, (0, _element.createElement)(_components.Image, (0, _extends2.default)({
          align: align && alignToFlex[align],
          alt: alt,
          isSelected: isSelected && !isCaptionSelected,
          isUploadFailed: isUploadFailed,
          isUploadInProgress: isUploadInProgress,
          onSelectMediaUploadOption: this.onSelectMediaUploadOption,
          openMediaOptions: openMediaOptions,
          retryMessage: retryMessage,
          url: url,
          shapeStyle: _styles.default[className],
          width: this.getWidth()
        }, hasImageContext ? additionalImageProps : {})));
      }
    }))), (0, _element.createElement)(_blockEditor.BlockCaption, {
      clientId: this.props.clientId,
      isSelected: this.state.isCaptionSelected,
      accessible: true,
      accessibilityLabelCreator: this.accessibilityLabelCreator,
      onFocus: this.onFocusCaption,
      onBlur: this.props.onBlur // always assign onBlur as props
      ,
      insertBlocksAfter: this.props.insertBlocksAfter
    }));

    return (0, _element.createElement)(_blockEditor.MediaUpload, {
      allowedTypes: [_blockEditor.MEDIA_TYPE_IMAGE],
      isReplacingMedia: true,
      onSelect: this.onSelectMediaUploadOption,
      render: ({
        open,
        getMediaOptions
      }) => {
        return getImageComponent(open, getMediaOptions);
      }
    });
  }

}

exports.ImageEdit = ImageEdit;

var _default = (0, _compose.compose)([(0, _data.withSelect)((select, props) => {
  const {
    getMedia
  } = select(_coreData.store);
  const {
    getSettings,
    wasBlockJustInserted
  } = select(_blockEditor.store);
  const {
    getEditedPostAttribute
  } = select('core/editor');
  const {
    attributes: {
      id,
      url
    },
    isSelected,
    clientId
  } = props;
  const {
    imageSizes,
    imageDefaultSize
  } = getSettings();
  const isNotFileUrl = id && (0, _url.getProtocol)(url) !== 'file:';
  const featuredImageId = getEditedPostAttribute('featured_media');
  const shouldGetMedia = isSelected && isNotFileUrl || // Edge case to update the image after uploading if the block gets unselected
  // Check if it's the original image and not the resized one with queryparams
  !isSelected && isNotFileUrl && url && !(0, _url.hasQueryArg)(url, 'w');
  return {
    image: shouldGetMedia ? getMedia(id) : null,
    imageSizes,
    imageDefaultSize,
    featuredImageId,
    wasBlockJustInserted: wasBlockJustInserted(clientId, 'inserter_menu')
  };
}), (0, _data.withDispatch)(dispatch => {
  return {
    closeSettingsBottomSheet() {
      dispatch(_editPost.store).closeGeneralSidebar();
    }

  };
}), _compose.withPreferredColorScheme])(ImageEdit);

exports.default = _default;
//# sourceMappingURL=edit.native.js.map