"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryContent = QueryContent;
exports.default = void 0;

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _blocks = require("@wordpress/blocks");

var _compose = require("@wordpress/compose");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _queryToolbar = _interopRequireDefault(require("./query-toolbar"));

var _queryInspectorControls = _interopRequireDefault(require("./query-inspector-controls"));

var _queryPlaceholder = _interopRequireDefault(require("./query-placeholder"));

var _constants = require("../constants");

var _utils = require("../utils");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const TEMPLATE = [['core/post-template']];

function QueryContent({
  attributes,
  setAttributes
}) {
  const {
    queryId,
    query,
    displayLayout,
    tagName: TagName = 'div',
    layout = {}
  } = attributes;
  const {
    __unstableMarkNextChangeAsNotPersistent
  } = (0, _data.useDispatch)(_blockEditor.store);
  const instanceId = (0, _compose.useInstanceId)(QueryContent);
  const {
    themeSupportsLayout
  } = (0, _data.useSelect)(select => {
    var _getSettings;

    const {
      getSettings
    } = select(_blockEditor.store);
    return {
      themeSupportsLayout: (_getSettings = getSettings()) === null || _getSettings === void 0 ? void 0 : _getSettings.supportsLayout
    };
  }, []);
  const defaultLayout = (0, _blockEditor.useSetting)('layout') || {};
  const usedLayout = !!layout && layout.inherit ? defaultLayout : layout;
  const blockProps = (0, _blockEditor.useBlockProps)();
  const innerBlocksProps = (0, _blockEditor.__experimentalUseInnerBlocksProps)(blockProps, {
    template: TEMPLATE,
    __experimentalLayout: themeSupportsLayout ? usedLayout : undefined
  });
  const {
    postsPerPage
  } = (0, _data.useSelect)(select => {
    const {
      getSettings
    } = select(_blockEditor.store);
    return {
      postsPerPage: +getSettings().postsPerPage || _constants.DEFAULTS_POSTS_PER_PAGE
    };
  }, []); // There are some effects running where some initialization logic is
  // happening and setting some values to some attributes (ex. queryId).
  // These updates can cause an `undo trap` where undoing will result in
  // resetting again, so we need to mark these changes as not persistent
  // with `__unstableMarkNextChangeAsNotPersistent`.
  // Changes in query property (which is an object) need to be in the same callback,
  // because updates are batched after the render and changes in different query properties
  // would cause to overide previous wanted changes.

  (0, _element.useEffect)(() => {
    const newQuery = {};

    if (!query.perPage && postsPerPage) {
      newQuery.perPage = postsPerPage;
    }

    if (!!Object.keys(newQuery).length) {
      __unstableMarkNextChangeAsNotPersistent();

      updateQuery(newQuery);
    }
  }, [query.perPage]); // We need this for multi-query block pagination.
  // Query parameters for each block are scoped to their ID.

  (0, _element.useEffect)(() => {
    if (!queryId) {
      __unstableMarkNextChangeAsNotPersistent();

      setAttributes({
        queryId: instanceId
      });
    }
  }, [queryId, instanceId]);

  const updateQuery = newQuery => setAttributes({
    query: { ...query,
      ...newQuery
    }
  });

  const updateDisplayLayout = newDisplayLayout => setAttributes({
    displayLayout: { ...displayLayout,
      ...newDisplayLayout
    }
  });

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_queryInspectorControls.default, {
    attributes: attributes,
    setQuery: updateQuery,
    setDisplayLayout: updateDisplayLayout
  }), (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_queryToolbar.default, {
    attributes: attributes,
    setQuery: updateQuery,
    setDisplayLayout: updateDisplayLayout
  })), (0, _element.createElement)(_blockEditor.InspectorControls, {
    __experimentalGroup: "advanced"
  }, (0, _element.createElement)(_components.SelectControl, {
    label: (0, _i18n.__)('HTML element'),
    options: [{
      label: (0, _i18n.__)('Default (<div>)'),
      value: 'div'
    }, {
      label: '<main>',
      value: 'main'
    }, {
      label: '<section>',
      value: 'section'
    }, {
      label: '<aside>',
      value: 'aside'
    }],
    value: TagName,
    onChange: value => setAttributes({
      tagName: value
    })
  })), (0, _element.createElement)(TagName, innerBlocksProps));
}

function QueryPatternSetup(props) {
  const {
    clientId,
    name: blockName
  } = props;
  const blockProps = (0, _blockEditor.useBlockProps)();
  const {
    replaceBlock,
    selectBlock
  } = (0, _data.useDispatch)(_blockEditor.store);

  const onBlockPatternSelect = blocks => {
    const clonedBlocks = blocks.map(block => (0, _blocks.cloneBlock)(block));
    const firstQueryClientId = (0, _utils.getFirstQueryClientIdFromBlocks)(clonedBlocks);
    replaceBlock(clientId, clonedBlocks);

    if (firstQueryClientId) {
      selectBlock(firstQueryClientId);
    }
  }; // `startBlankComponent` is what to render when clicking `Start blank`
  // or if no matched patterns are found.


  return (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_blockEditor.__experimentalBlockPatternSetup, {
    blockName: blockName,
    clientId: clientId,
    startBlankComponent: (0, _element.createElement)(_queryPlaceholder.default, props),
    onBlockPatternSelect: onBlockPatternSelect
  }));
}

const QueryEdit = props => {
  const {
    clientId
  } = props;
  const hasInnerBlocks = (0, _data.useSelect)(select => !!select(_blockEditor.store).getBlocks(clientId).length, [clientId]);
  const Component = hasInnerBlocks ? QueryContent : QueryPatternSetup;
  return (0, _element.createElement)(Component, props);
};

var _default = QueryEdit;
exports.default = _default;
//# sourceMappingURL=index.js.map