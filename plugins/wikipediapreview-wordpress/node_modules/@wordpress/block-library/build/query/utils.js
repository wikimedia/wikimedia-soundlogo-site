"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstQueryClientIdFromBlocks = exports.usePostTypes = exports.getTermsInfo = void 0;

var _data = require("@wordpress/data");

var _element = require("@wordpress/element");

var _coreData = require("@wordpress/core-data");

/**
 * WordPress dependencies
 */

/**
 * WordPress term object from REST API.
 * Categories ref: https://developer.wordpress.org/rest-api/reference/categories/
 * Tags ref: https://developer.wordpress.org/rest-api/reference/tags/
 *
 * @typedef {Object} WPTerm
 * @property {number} id          Unique identifier for the term.
 * @property {number} count       Number of published posts for the term.
 * @property {string} description HTML description of the term.
 * @property {string} link        URL of the term.
 * @property {string} name        HTML title for the term.
 * @property {string} slug        An alphanumeric identifier for the term unique to its type.
 * @property {string} taxonomy    Type attribution for the term.
 * @property {Object} meta        Meta fields
 * @property {number} [parent]    The parent term ID.
 */

/**
 * The object used in Query block that contains info and helper mappings
 * from an array of WPTerm.
 *
 * @typedef {Object} QueryTermsInfo
 * @property {WPTerm[]}               terms     The array of terms.
 * @property {Object<string, WPTerm>} mapById   Object mapping with the term id as key and the term as value.
 * @property {Object<string, WPTerm>} mapByName Object mapping with the term name as key and the term as value.
 * @property {string[]}               names     Array with the terms' names.
 */

/**
 * Returns a helper object with mapping from WPTerms.
 *
 * @param {WPTerm[]} terms The terms to extract of helper object.
 * @return {QueryTermsInfo} The object with the terms information.
 */
const getTermsInfo = terms => {
  const mapping = terms === null || terms === void 0 ? void 0 : terms.reduce((accumulator, term) => {
    const {
      mapById,
      mapByName,
      names
    } = accumulator;
    mapById[term.id] = term;
    mapByName[term.name] = term;
    names.push(term.name);
    return accumulator;
  }, {
    mapById: {},
    mapByName: {},
    names: []
  });
  return {
    terms,
    ...mapping
  };
};
/**
 * Returns a helper object that contains:
 * 1. An `options` object from the available post types, to be passed to a `SelectControl`.
 * 2. A helper map with available taxonomies per post type.
 *
 * @return {Object} The helper object related to post types.
 */


exports.getTermsInfo = getTermsInfo;

const usePostTypes = () => {
  const {
    postTypes
  } = (0, _data.useSelect)(select => {
    var _getPostTypes;

    const {
      getPostTypes
    } = select(_coreData.store);
    const excludedPostTypes = ['attachment'];
    const filteredPostTypes = (_getPostTypes = getPostTypes({
      per_page: -1
    })) === null || _getPostTypes === void 0 ? void 0 : _getPostTypes.filter(({
      viewable,
      slug
    }) => viewable && !excludedPostTypes.includes(slug));
    return {
      postTypes: filteredPostTypes
    };
  }, []);
  const postTypesTaxonomiesMap = (0, _element.useMemo)(() => {
    if (!(postTypes !== null && postTypes !== void 0 && postTypes.length)) return;
    return postTypes.reduce((accumulator, type) => {
      accumulator[type.slug] = type.taxonomies;
      return accumulator;
    }, {});
  }, [postTypes]);
  const postTypesSelectOptions = (0, _element.useMemo)(() => (postTypes || []).map(({
    labels,
    slug
  }) => ({
    label: labels.singular_name,
    value: slug
  })), [postTypes]);
  return {
    postTypesTaxonomiesMap,
    postTypesSelectOptions
  };
};
/**
 * Recurses over a list of blocks and returns the first found
 * Query Loop block's clientId.
 *
 * @param {WPBlock[]} blocks The list of blocks to look through.
 * @return {string=} The first found Query Loop's clientId.
 */


exports.usePostTypes = usePostTypes;

const getFirstQueryClientIdFromBlocks = blocks => {
  const blocksQueue = [...blocks];

  while (blocksQueue.length > 0) {
    var _block$innerBlocks;

    const block = blocksQueue.shift();

    if (block.name === 'core/query') {
      return block.clientId;
    }

    (_block$innerBlocks = block.innerBlocks) === null || _block$innerBlocks === void 0 ? void 0 : _block$innerBlocks.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }
};

exports.getFirstQueryClientIdFromBlocks = getFirstQueryClientIdFromBlocks;
//# sourceMappingURL=utils.js.map