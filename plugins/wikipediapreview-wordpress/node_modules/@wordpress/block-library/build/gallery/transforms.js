"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _blocks = require("@wordpress/blocks");

var _blob = require("@wordpress/blob");

var _data = require("@wordpress/data");

var _blockEditor = require("@wordpress/block-editor");

var _hooks = require("@wordpress/hooks");

var _constants = require("./constants");

var _constants2 = require("./v1/constants");

var _shared = require("./shared");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const parseShortcodeIds = ids => {
  if (!ids) {
    return [];
  }

  return ids.split(',').map(id => parseInt(id, 10));
};
/**
 * Third party block plugins don't have an easy way to detect if the
 * innerBlocks version of the Gallery is running when they run a
 * 3rdPartyBlock -> GalleryBlock transform so this tranform filter
 * will handle this. Once the innerBlocks version is the default
 * in a core release, this could be deprecated and removed after
 * plugin authors have been given time to update transforms.
 *
 * @typedef  {Object} Attributes
 * @typedef  {Object} Block
 * @property {Attributes} attributes The attributes of the block.
 * @param    {Block}      block      The transformed block.
 * @return   {Block}                 The transformed block.
 */


function updateThirdPartyTransformToGallery(block) {
  var _block$attributes;

  const settings = (0, _data.select)(_blockEditor.store).getSettings();

  if (settings.__unstableGalleryWithImageBlocks && block.name === 'core/gallery' && ((_block$attributes = block.attributes) === null || _block$attributes === void 0 ? void 0 : _block$attributes.images.length) > 0) {
    const innerBlocks = block.attributes.images.map(({
      url,
      id,
      alt
    }) => {
      return (0, _blocks.createBlock)('core/image', {
        url,
        id: id ? parseInt(id, 10) : null,
        alt,
        sizeSlug: block.attributes.sizeSlug,
        linkDestination: block.attributes.linkDestination
      });
    });
    delete block.attributes.ids;
    delete block.attributes.images;
    block.innerBlocks = innerBlocks;
  }

  return block;
}

(0, _hooks.addFilter)('blocks.switchToBlockType.transformedBlock', 'core/gallery/update-third-party-transform-to', updateThirdPartyTransformToGallery);
/**
 * Third party block plugins don't have an easy way to detect if the
 * innerBlocks version of the Gallery is running when they run a
 * GalleryBlock -> 3rdPartyBlock transform so this transform filter
 * will handle this. Once the innerBlocks version is the default
 * in a core release, this could be deprecated and removed after
 * plugin authors have been given time to update transforms.
 *
 * @typedef  {Object} Attributes
 * @typedef  {Object} Block
 * @property {Attributes} attributes The attributes of the block.
 * @param    {Block}      toBlock    The block to transform to.
 * @param    {Block[]}    fromBlocks The blocks to transform from.
 * @return   {Block}                 The transformed block.
 */

function updateThirdPartyTransformFromGallery(toBlock, fromBlocks) {
  const from = Array.isArray(fromBlocks) ? fromBlocks : [fromBlocks];
  const galleryBlock = from.find(transformedBlock => {
    var _transformedBlock$att;

    return transformedBlock.name === 'core/gallery' && transformedBlock.innerBlocks.length > 0 && !((_transformedBlock$att = transformedBlock.attributes.images) !== null && _transformedBlock$att !== void 0 && _transformedBlock$att.length) > 0 && !toBlock.name.includes('core/');
  });

  if (galleryBlock) {
    const images = galleryBlock.innerBlocks.map(({
      attributes: {
        url,
        id,
        alt
      }
    }) => ({
      url,
      id: id ? parseInt(id, 10) : null,
      alt
    }));
    const ids = images.map(({
      id
    }) => id);
    galleryBlock.attributes.images = images;
    galleryBlock.attributes.ids = ids;
  }

  return toBlock;
}

(0, _hooks.addFilter)('blocks.switchToBlockType.transformedBlock', 'core/gallery/update-third-party-transform-from', updateThirdPartyTransformFromGallery);
const transforms = {
  from: [{
    type: 'block',
    isMultiBlock: true,
    blocks: ['core/image'],
    transform: attributes => {
      // Init the align and size from the first item which may be either the placeholder or an image.
      let {
        align,
        sizeSlug
      } = attributes[0]; // Loop through all the images and check if they have the same align and size.

      align = (0, _lodash.every)(attributes, ['align', align]) ? align : undefined;
      sizeSlug = (0, _lodash.every)(attributes, ['sizeSlug', sizeSlug]) ? sizeSlug : undefined;
      const validImages = (0, _lodash.filter)(attributes, ({
        url
      }) => url);
      const settings = (0, _data.select)(_blockEditor.store).getSettings();

      if (settings.__unstableGalleryWithImageBlocks) {
        const innerBlocks = validImages.map(image => {
          return (0, _blocks.createBlock)('core/image', image);
        });
        return (0, _blocks.createBlock)('core/gallery', {
          align,
          sizeSlug
        }, innerBlocks);
      }

      return (0, _blocks.createBlock)('core/gallery', {
        images: validImages.map(({
          id,
          url,
          alt,
          caption
        }) => ({
          id: (0, _lodash.toString)(id),
          url,
          alt,
          caption
        })),
        ids: validImages.map(({
          id
        }) => parseInt(id, 10)),
        align,
        sizeSlug
      });
    }
  }, {
    type: 'shortcode',
    tag: 'gallery',
    attributes: {
      images: {
        type: 'array',
        shortcode: ({
          named: {
            ids
          }
        }) => {
          const settings = (0, _data.select)(_blockEditor.store).getSettings();

          if (!settings.__unstableGalleryWithImageBlocks) {
            return parseShortcodeIds(ids).map(id => ({
              id: (0, _lodash.toString)(id)
            }));
          }
        }
      },
      ids: {
        type: 'array',
        shortcode: ({
          named: {
            ids
          }
        }) => {
          const settings = (0, _data.select)(_blockEditor.store).getSettings();

          if (!settings.__unstableGalleryWithImageBlocks) {
            return parseShortcodeIds(ids);
          }
        }
      },
      shortCodeTransforms: {
        type: 'array',
        shortcode: ({
          named: {
            ids
          }
        }) => {
          const settings = (0, _data.select)(_blockEditor.store).getSettings();

          if (settings.__unstableGalleryWithImageBlocks) {
            return parseShortcodeIds(ids).map(id => ({
              id: parseInt(id)
            }));
          }
        }
      },
      columns: {
        type: 'number',
        shortcode: ({
          named: {
            columns = '3'
          }
        }) => {
          return parseInt(columns, 10);
        }
      },
      linkTo: {
        type: 'string',
        shortcode: ({
          named: {
            link
          }
        }) => {
          const settings = (0, _data.select)(_blockEditor.store).getSettings();

          if (!settings.__unstableGalleryWithImageBlocks) {
            switch (link) {
              case 'post':
                return _constants2.LINK_DESTINATION_ATTACHMENT;

              case 'file':
                return _constants2.LINK_DESTINATION_MEDIA;

              default:
                return _constants2.LINK_DESTINATION_ATTACHMENT;
            }
          }

          switch (link) {
            case 'post':
              return _constants.LINK_DESTINATION_ATTACHMENT;

            case 'file':
              return _constants.LINK_DESTINATION_MEDIA;

            default:
              return _constants.LINK_DESTINATION_NONE;
          }
        }
      }
    },

    isMatch({
      named
    }) {
      return undefined !== named.ids;
    }

  }, {
    // When created by drag and dropping multiple files on an insertion point. Because multiple
    // files must not be transformed to a gallery when dropped within a gallery there is another transform
    // within the image block to handle that case. Therefore this transform has to have priority 1
    // set so that it overrrides the image block transformation when mulitple images are dropped outside
    // of a gallery block.
    type: 'files',
    priority: 1,

    isMatch(files) {
      return files.length !== 1 && (0, _lodash.every)(files, file => file.type.indexOf('image/') === 0);
    },

    transform(files) {
      const settings = (0, _data.select)(_blockEditor.store).getSettings();

      if (settings.__unstableGalleryWithImageBlocks) {
        const innerBlocks = files.map(file => (0, _blocks.createBlock)('core/image', {
          url: (0, _blob.createBlobURL)(file)
        }));
        return (0, _blocks.createBlock)('core/gallery', {}, innerBlocks);
      }

      const block = (0, _blocks.createBlock)('core/gallery', {
        images: files.map(file => (0, _shared.pickRelevantMediaFiles)({
          url: (0, _blob.createBlobURL)(file)
        }))
      });
      return block;
    }

  }],
  to: [{
    type: 'block',
    blocks: ['core/image'],
    transform: ({
      align,
      images,
      ids,
      sizeSlug
    }, innerBlocks) => {
      const settings = (0, _data.select)(_blockEditor.store).getSettings();

      if (settings.__unstableGalleryWithImageBlocks) {
        if (innerBlocks.length > 0) {
          return innerBlocks.map(({
            attributes: {
              id,
              url,
              alt,
              caption,
              imageSizeSlug
            }
          }) => (0, _blocks.createBlock)('core/image', {
            id,
            url,
            alt,
            caption,
            sizeSlug: imageSizeSlug,
            align
          }));
        }

        return (0, _blocks.createBlock)('core/image', {
          align
        });
      }

      if (images.length > 0) {
        return images.map(({
          url,
          alt,
          caption
        }, index) => (0, _blocks.createBlock)('core/image', {
          id: ids[index],
          url,
          alt,
          caption,
          align,
          sizeSlug
        }));
      }

      return (0, _blocks.createBlock)('core/image', {
        align
      });
    }
  }]
};
var _default = transforms;
exports.default = _default;
//# sourceMappingURL=transforms.js.map