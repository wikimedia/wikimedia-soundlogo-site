{"version":3,"sources":["@wordpress/block-library/src/columns/utils.js"],"names":["toWidthPrecision","value","unitlessValue","parseFloat","Number","isFinite","toFixed","undefined","getEffectiveColumnWidth","block","totalBlockCount","width","attributes","getTotalColumnsWidth","blocks","length","getColumnWidths","reduce","accumulator","Object","assign","clientId","getRedistributedColumnWidths","availableWidth","totalWidth","newWidth","hasExplicitPercentColumnWidths","every","blockWidth","endsWith","getMappedColumnWidths","widths","map","getWidths","withParsing","innerColumn","innerColumnWidth","getWidthWithUnit","unit","isPercentageUnit","Math","min"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { sumBy, merge, mapValues } from 'lodash';\n\n/**\n * Returns a column width attribute value rounded to standard precision.\n * Returns `undefined` if the value is not a valid finite number.\n *\n * @param {?number} value Raw value.\n *\n * @return {number} Value rounded to standard precision.\n */\nexport const toWidthPrecision = ( value ) => {\n\tconst unitlessValue = parseFloat( value );\n\treturn Number.isFinite( unitlessValue )\n\t\t? parseFloat( unitlessValue.toFixed( 2 ) )\n\t\t: undefined;\n};\n/**\n * Returns an effective width for a given block. An effective width is equal to\n * its attribute value if set, or a computed value assuming equal distribution.\n *\n * @param {WPBlock} block           Block object.\n * @param {number}  totalBlockCount Total number of blocks in Columns.\n *\n * @return {number} Effective column width.\n */\nexport function getEffectiveColumnWidth( block, totalBlockCount ) {\n\tconst { width = 100 / totalBlockCount } = block.attributes;\n\treturn toWidthPrecision( width );\n}\n\n/**\n * Returns the total width occupied by the given set of column blocks.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {number} Total width occupied by blocks.\n */\nexport function getTotalColumnsWidth(\n\tblocks,\n\ttotalBlockCount = blocks.length\n) {\n\treturn sumBy( blocks, ( block ) =>\n\t\tgetEffectiveColumnWidth( block, totalBlockCount )\n\t);\n}\n\n/**\n * Returns an object of `clientId` → `width` of effective column widths.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {Object<string,number>} Column widths.\n */\nexport function getColumnWidths( blocks, totalBlockCount = blocks.length ) {\n\treturn blocks.reduce( ( accumulator, block ) => {\n\t\tconst width = getEffectiveColumnWidth( block, totalBlockCount );\n\t\treturn Object.assign( accumulator, { [ block.clientId ]: width } );\n\t}, {} );\n}\n\n/**\n * Returns an object of `clientId` → `width` of column widths as redistributed\n * proportional to their current widths, constrained or expanded to fit within\n * the given available width.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {number}    availableWidth  Maximum width to fit within.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {Object<string,number>} Redistributed column widths.\n */\nexport function getRedistributedColumnWidths(\n\tblocks,\n\tavailableWidth,\n\ttotalBlockCount = blocks.length\n) {\n\tconst totalWidth = getTotalColumnsWidth( blocks, totalBlockCount );\n\n\treturn mapValues( getColumnWidths( blocks, totalBlockCount ), ( width ) => {\n\t\tconst newWidth = ( availableWidth * width ) / totalWidth;\n\t\treturn toWidthPrecision( newWidth );\n\t} );\n}\n\n/**\n * Returns true if column blocks within the provided set are assigned with\n * explicit widths, or false otherwise.\n *\n * @param {WPBlock[]} blocks Block objects.\n *\n * @return {boolean} Whether columns have explicit widths.\n */\nexport function hasExplicitPercentColumnWidths( blocks ) {\n\treturn blocks.every( ( block ) => {\n\t\tconst blockWidth = block.attributes.width;\n\t\treturn Number.isFinite(\n\t\t\tblockWidth?.endsWith?.( '%' )\n\t\t\t\t? parseFloat( blockWidth )\n\t\t\t\t: blockWidth\n\t\t);\n\t} );\n}\n\n/**\n * Returns a copy of the given set of blocks with new widths assigned from the\n * provided object of redistributed column widths.\n *\n * @param {WPBlock[]}             blocks Block objects.\n * @param {Object<string,number>} widths Redistributed column widths.\n *\n * @return {WPBlock[]} blocks Mapped block objects.\n */\nexport function getMappedColumnWidths( blocks, widths ) {\n\treturn blocks.map( ( block ) =>\n\t\tmerge( {}, block, {\n\t\t\tattributes: {\n\t\t\t\twidth: `${ widths[ block.clientId ] }%`,\n\t\t\t},\n\t\t} )\n\t);\n}\n\n/**\n * Returns an array with columns widths values, parsed or no depends on `withParsing` flag.\n *\n * @param {WPBlock[]} blocks      Block objects.\n * @param {?boolean}  withParsing Whether value has to be parsed.\n *\n * @return {Array<number,string>} Column widths.\n */\nexport function getWidths( blocks, withParsing = true ) {\n\treturn blocks.map( ( innerColumn ) => {\n\t\tconst innerColumnWidth =\n\t\t\tinnerColumn.attributes.width || 100 / blocks.length;\n\n\t\treturn withParsing ? parseFloat( innerColumnWidth ) : innerColumnWidth;\n\t} );\n}\n\n/**\n * Returns a column width with unit.\n *\n * @param {string} width Column width.\n * @param {string} unit  Column width unit.\n *\n * @return {string} Column width with unit.\n */\nexport function getWidthWithUnit( width, unit ) {\n\twidth = 0 > parseFloat( width ) ? '0' : width;\n\n\tif ( isPercentageUnit( unit ) ) {\n\t\twidth = Math.min( width, 100 );\n\t}\n\n\treturn `${ width }${ unit }`;\n}\n\n/**\n * Returns a boolean whether passed unit is percentage\n *\n * @param {string} unit Column width unit.\n *\n * @return {boolean} \tWhether unit is '%'.\n */\nexport function isPercentageUnit( unit ) {\n\treturn unit === '%';\n}\n"]}