"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TableOfContentsEdit;

var _element = require("@wordpress/element");

var _lodash = require("lodash");

var _blockEditor = require("@wordpress/block-editor");

var _blocks = require("@wordpress/blocks");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _i18n = require("@wordpress/i18n");

var _list = _interopRequireDefault(require("./list"));

var _utils = require("./utils");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Table of Contents block edit component.
 *
 * @param {Object}                       props                                   The props.
 * @param {Object}                       props.attributes                        The block attributes.
 * @param {boolean}                      props.attributes.onlyIncludeCurrentPage
 *                                                                               Whether to only include headings from the current page (if the post is
 *                                                                               paginated).
 * @param {string}                       props.clientId
 * @param {(attributes: Object) => void} props.setAttributes
 *
 * @return {WPComponent} The component.
 */
function TableOfContentsEdit({
  attributes: {
    onlyIncludeCurrentPage
  },
  clientId,
  setAttributes
}) {
  const blockProps = (0, _blockEditor.useBlockProps)(); // Local state; not saved to block attributes. The saved block is dynamic and uses PHP to generate its content.

  const [headings, setHeadings] = (0, _element.useState)([]);
  const [headingTree, setHeadingTree] = (0, _element.useState)([]);
  const {
    listBlockExists,
    postContent
  } = (0, _data.useSelect)(select => ({
    listBlockExists: !!select(_blocks.store).getBlockType('core/list'),
    // FIXME: @wordpress/block-library should not depend on @wordpress/editor.
    // Blocks can be loaded into a *non-post* block editor.
    // eslint-disable-next-line @wordpress/data-no-store-string-literals
    postContent: select('core/editor').getEditedPostContent()
  }), []); // The page this block would be part of on the front-end. For performance
  // reasons, this is only calculated when onlyIncludeCurrentPage is true.

  const pageIndex = (0, _data.useSelect)(select => {
    if (!onlyIncludeCurrentPage) {
      return null;
    }

    const {
      getBlockAttributes,
      getBlockIndex,
      getBlockName,
      getBlockOrder
    } = select(_blockEditor.store);
    const blockIndex = getBlockIndex(clientId);
    const blockOrder = getBlockOrder(); // Calculate which page the block will appear in on the front-end by
    // counting how many <!--nextpage--> tags precede it.
    // Unfortunately, this implementation only accounts for Page Break and
    // Classic blocks, so if there are any <!--nextpage--> tags in any
    // other block, they won't be counted. This will result in the table
    // of contents showing headings from the wrong page if
    // onlyIncludeCurrentPage === true. Thankfully, this issue only
    // affects the editor implementation.

    let page = 1;

    for (let i = 0; i < blockIndex; i++) {
      const blockName = getBlockName(blockOrder[i]);

      if (blockName === 'core/nextpage') {
        page++;
      } else if (blockName === 'core/freeform') {
        var _getBlockAttributes$c;

        // Count the page breaks inside the Classic block.
        const pageBreaks = (_getBlockAttributes$c = getBlockAttributes(blockOrder[i]).content) === null || _getBlockAttributes$c === void 0 ? void 0 : _getBlockAttributes$c.match(/<!--nextpage-->/g);

        if (pageBreaks !== null && pageBreaks !== undefined) {
          page += pageBreaks.length;
        }
      }
    }

    return page;
  }, [clientId, onlyIncludeCurrentPage]);
  (0, _element.useEffect)(() => {
    let latestHeadings;

    if (onlyIncludeCurrentPage) {
      const pagesOfContent = postContent.split('<!--nextpage-->');
      latestHeadings = (0, _utils.getHeadingsFromContent)(pagesOfContent[pageIndex - 1]);
    } else {
      latestHeadings = (0, _utils.getHeadingsFromContent)(postContent);
    }

    if (!(0, _lodash.isEqual)(headings, latestHeadings)) {
      setHeadings(latestHeadings);
      setHeadingTree((0, _utils.linearToNestedHeadingList)(latestHeadings));
    }
  }, [pageIndex, postContent, onlyIncludeCurrentPage]);
  const {
    replaceBlocks
  } = (0, _data.useDispatch)(_blockEditor.store);
  const toolbarControls = listBlockExists && (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_components.ToolbarGroup, null, (0, _element.createElement)(_components.ToolbarButton, {
    onClick: () => replaceBlocks(clientId, (0, _blocks.createBlock)('core/list', {
      values: (0, _element.renderToString)((0, _element.createElement)(_list.default, {
        nestedHeadingList: headingTree
      }))
    }))
  }, (0, _i18n.__)('Convert to static list'))));
  const inspectorControls = (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Table of Contents settings')
  }, (0, _element.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Only include current page'),
    checked: onlyIncludeCurrentPage,
    onChange: value => setAttributes({
      onlyIncludeCurrentPage: value
    }),
    help: onlyIncludeCurrentPage ? (0, _i18n.__)('Only including headings from the current page (if the post is paginated).') : (0, _i18n.__)('Toggle to only include headings from the current page (if the post is paginated).')
  }))); // If there are no headings or the only heading is empty.
  // Note that the toolbar controls are intentionally omitted since the
  // "Convert to static list" option is useless to the placeholder state.

  if (headings.length === 0) {
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Placeholder, {
      icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
        icon: "list-view"
      }),
      label: "Table of Contents",
      instructions: (0, _i18n.__)('Start adding Heading blocks to create a table of contents. Headings with HTML anchors will be linked here.')
    })), inspectorControls);
  }

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("nav", blockProps, (0, _element.createElement)("ul", null, (0, _element.createElement)(_list.default, {
    nestedHeadingList: headingTree
  }))), toolbarControls, inspectorControls);
}
//# sourceMappingURL=edit.js.map