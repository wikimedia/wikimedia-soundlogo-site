{"version":3,"sources":["@wordpress/block-library/src/table-of-contents/utils.js"],"names":["getHeadingsFromHeadingElements","headingElements","map","heading","level","parseInt","tagName","anchor","hasAttribute","id","content","textContent","getHeadingsFromContent","tempPostContentDOM","document","createElement","innerHTML","template","querySelectorAll","remove","linearToNestedHeadingList","headingList","index","nestedHeadingList","forEach","key","undefined","endOfSlice","length","i","push","children","slice"],"mappings":"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","sourcesContent":["/**\n * @typedef WPHeadingData\n *\n * @property {string} anchor  The anchor link to the heading, or '' if none.\n * @property {string} content The plain text content of the heading.\n * @property {number} level   The heading level.\n */\n\n/**\n * Extracts text, anchor, and level from a list of heading elements.\n *\n * @param {NodeList} headingElements The list of heading elements.\n *\n * @return {WPHeadingData[]} The list of heading parameters.\n */\nexport function getHeadingsFromHeadingElements( headingElements ) {\n\treturn [ ...headingElements ].map( ( heading ) => ( {\n\t\t// A little hacky, but since we know at this point that the tag will\n\t\t// be an H1-H6, we can just grab the 2nd character of the tag name and\n\t\t// convert it to an integer. Should be faster than conditionals.\n\t\tlevel: parseInt( heading.tagName[ 1 ], 10 ),\n\t\tanchor: heading.hasAttribute( 'id' ) ? `#${ heading.id }` : '',\n\t\tcontent: heading.textContent,\n\t} ) );\n}\n\n/**\n * Extracts heading data from the provided content.\n *\n * @param {string} content The content to extract heading data from.\n *\n * @return {WPHeadingData[]} The list of heading parameters.\n */\nexport function getHeadingsFromContent( content ) {\n\t// Create a temporary container to put the post content into, so we can\n\t// use the DOM to find all the headings.\n\tconst tempPostContentDOM = document.createElement( 'div' );\n\ttempPostContentDOM.innerHTML = content;\n\n\t// Remove template elements so that headings inside them aren't counted.\n\t// This is only needed for IE11, which doesn't recognize the element and\n\t// treats it like a div.\n\tfor ( const template of tempPostContentDOM.querySelectorAll(\n\t\t'template'\n\t) ) {\n\t\ttemplate.remove();\n\t}\n\n\tconst headingElements = tempPostContentDOM.querySelectorAll(\n\t\t'h1:not(:empty), h2:not(:empty), h3:not(:empty), h4:not(:empty), h5:not(:empty), h6:not(:empty)'\n\t);\n\n\treturn getHeadingsFromHeadingElements( headingElements );\n}\n\n/**\n * @typedef WPNestedHeadingData\n *\n * @property {WPHeadingData}              heading  The heading content, anchor,\n *                                                 and level.\n * @property {number}                     index    The index of this heading\n *                                                 node in the entire nested\n *                                                 list of heading data.\n * @property {WPNestedHeadingData[]|null} children The sub-headings of this\n *                                                 heading, if any.\n */\n\n/**\n * Takes a flat list of heading parameters and nests them based on each header's\n * immediate parent's level.\n *\n * @param {WPHeadingData[]} headingList The flat list of headings to nest.\n * @param {number}          index       The current list index.\n *\n * @return {WPNestedHeadingData[]} The nested list of headings.\n */\nexport function linearToNestedHeadingList( headingList, index = 0 ) {\n\tconst nestedHeadingList = [];\n\n\theadingList.forEach( ( heading, key ) => {\n\t\tif ( heading.content === '' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure we are only working with the same level as the first iteration in our set.\n\t\tif ( heading.level === headingList[ 0 ].level ) {\n\t\t\t// Check that the next iteration will return a value.\n\t\t\t// If it does and the next level is greater than the current level,\n\t\t\t// the next iteration becomes a child of the current iteration.\n\t\t\tif (\n\t\t\t\theadingList[ key + 1 ] !== undefined &&\n\t\t\t\theadingList[ key + 1 ].level > heading.level\n\t\t\t) {\n\t\t\t\t// We need to calculate the last index before the next iteration that has the same level (siblings).\n\t\t\t\t// We then use this last index to slice the array for use in recursion.\n\t\t\t\t// This prevents duplicate nodes.\n\t\t\t\tlet endOfSlice = headingList.length;\n\t\t\t\tfor ( let i = key + 1; i < headingList.length; i++ ) {\n\t\t\t\t\tif ( headingList[ i ].level === heading.level ) {\n\t\t\t\t\t\tendOfSlice = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We found a child node: Push a new node onto the return array with children.\n\t\t\t\tnestedHeadingList.push( {\n\t\t\t\t\theading,\n\t\t\t\t\tindex: index + key,\n\t\t\t\t\tchildren: linearToNestedHeadingList(\n\t\t\t\t\t\theadingList.slice( key + 1, endOfSlice ),\n\t\t\t\t\t\tindex + key + 1\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t// No child node: Push a new node onto the return array.\n\t\t\t\tnestedHeadingList.push( {\n\t\t\t\t\theading,\n\t\t\t\t\tindex: index + key,\n\t\t\t\t\tchildren: null,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t} );\n\n\treturn nestedHeadingList;\n}\n"]}