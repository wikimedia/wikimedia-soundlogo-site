"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useAvailableAlignments;

var _data = require("@wordpress/data");

var _layout = require("../block-list/layout");

var _store = require("../../store");

var _layouts = require("../../layouts");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const DEFAULT_CONTROLS = ['none', 'left', 'center', 'right', 'wide', 'full'];
const WIDE_CONTROLS = ['wide', 'full'];

function useAvailableAlignments(controls = DEFAULT_CONTROLS) {
  // Always add the `none` option if not exists.
  if (!controls.includes('none')) {
    controls.unshift('none');
  }

  const {
    wideControlsEnabled = false,
    themeSupportsLayout
  } = (0, _data.useSelect)(select => {
    const {
      getSettings
    } = select(_store.store);
    const settings = getSettings();
    return {
      wideControlsEnabled: settings.alignWide,
      themeSupportsLayout: settings.supportsLayout
    };
  }, []);
  const layout = (0, _layout.useLayout)();
  const layoutType = (0, _layouts.getLayoutType)(layout === null || layout === void 0 ? void 0 : layout.type);
  const layoutAlignments = layoutType.getAlignments(layout);

  if (themeSupportsLayout) {
    return layoutAlignments.filter(({
      name: alignmentName
    }) => controls.includes(alignmentName));
  } // Starting here, it's the fallback for themes not supporting the layout config.


  if (layoutType.name !== 'default') {
    return [];
  }

  const {
    alignments: availableAlignments = DEFAULT_CONTROLS
  } = layout;
  const enabledControls = controls.filter(control => (layout.alignments || // Ignore the global wideAlignment check if the layout explicitely defines alignments.
  wideControlsEnabled || !WIDE_CONTROLS.includes(control)) && availableAlignments.includes(control)).map(enabledControl => ({
    name: enabledControl
  }));
  return enabledControls;
}
//# sourceMappingURL=use-available-alignments.js.map