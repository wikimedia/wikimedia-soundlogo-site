"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _i18n = require("@wordpress/i18n");

var _coreData = require("@wordpress/core-data");

var _blockEditor = require("@wordpress/block-editor");

var _reusableBlocks = require("@wordpress/reusable-blocks");

var _notices = require("@wordpress/notices");

var _withRegistryProvider = _interopRequireDefault(require("./with-registry-provider"));

var _store = require("../../store");

var _useBlockEditorSettings = _interopRequireDefault(require("./use-block-editor-settings"));

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function EditorProvider({
  __unstableTemplate,
  post,
  settings,
  recovery,
  initialEdits,
  children
}) {
  const defaultBlockContext = (0, _element.useMemo)(() => {
    if (post.type === 'wp_template') {
      return {};
    }

    return {
      postId: post.id,
      postType: post.type
    };
  }, [post.id, post.type]);
  const {
    selection,
    isReady
  } = (0, _data.useSelect)(select => {
    const {
      getEditorSelection,
      __unstableIsEditorReady
    } = select(_store.store);
    return {
      isReady: __unstableIsEditorReady(),
      selection: getEditorSelection()
    };
  }, []);
  const {
    id,
    type
  } = __unstableTemplate !== null && __unstableTemplate !== void 0 ? __unstableTemplate : post;
  const [blocks, onInput, onChange] = (0, _coreData.useEntityBlockEditor)('postType', type, {
    id
  });
  const editorSettings = (0, _useBlockEditorSettings.default)(settings, !!__unstableTemplate);
  const {
    updatePostLock,
    setupEditor,
    updateEditorSettings,
    __experimentalTearDownEditor
  } = (0, _data.useDispatch)(_store.store);
  const {
    createWarningNotice
  } = (0, _data.useDispatch)(_notices.store); // Initialize and tear down the editor.
  // Ideally this should be synced on each change and not just something you do once.

  (0, _element.useLayoutEffect)(() => {
    // Assume that we don't need to initialize in the case of an error recovery.
    if (recovery) {
      return;
    }

    updatePostLock(settings.postLock);
    setupEditor(post, initialEdits, settings.template);

    if (settings.autosave) {
      createWarningNotice((0, _i18n.__)('There is an autosave of this post that is more recent than the version below.'), {
        id: 'autosave-exists',
        actions: [{
          label: (0, _i18n.__)('View the autosave'),
          url: settings.autosave.editLink
        }]
      });
    }

    return () => {
      __experimentalTearDownEditor();
    };
  }, []); // Synchronize the editor settings as they change

  (0, _element.useEffect)(() => {
    updateEditorSettings(settings);
  }, [settings]);

  if (!isReady) {
    return null;
  }

  return (0, _element.createElement)(_coreData.EntityProvider, {
    kind: "root",
    type: "site"
  }, (0, _element.createElement)(_coreData.EntityProvider, {
    kind: "postType",
    type: post.type,
    id: post.id
  }, (0, _element.createElement)(_blockEditor.BlockContextProvider, {
    value: defaultBlockContext
  }, (0, _element.createElement)(_blockEditor.BlockEditorProvider, {
    value: blocks,
    onChange: onChange,
    onInput: onInput,
    selection: selection,
    settings: editorSettings,
    useSubRegistry: false
  }, children, (0, _element.createElement)(_reusableBlocks.ReusableBlocksMenuItems, null)))));
}

var _default = (0, _withRegistryProvider.default)(EditorProvider);

exports.default = _default;
//# sourceMappingURL=index.js.map