"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PostPublishPanel = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _lodash = require("lodash");

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _icons = require("@wordpress/icons");

var _coreData = require("@wordpress/core-data");

var _postPublishButton = _interopRequireDefault(require("../post-publish-button"));

var _prepublish = _interopRequireDefault(require("./prepublish"));

var _postpublish = _interopRequireDefault(require("./postpublish"));

var _store = require("../../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
class PostPublishPanel extends _element.Component {
  constructor() {
    super(...arguments);
    this.onSubmit = this.onSubmit.bind(this);
  }

  componentDidUpdate(prevProps) {
    // Automatically collapse the publish sidebar when a post
    // is published and the user makes an edit.
    if (prevProps.isPublished && !this.props.isSaving && this.props.isDirty) {
      this.props.onClose();
    }
  }

  onSubmit() {
    const {
      onClose,
      hasPublishAction,
      isPostTypeViewable
    } = this.props;

    if (!hasPublishAction || !isPostTypeViewable) {
      onClose();
    }
  }

  render() {
    const {
      forceIsDirty,
      forceIsSaving,
      isBeingScheduled,
      isPublished,
      isPublishSidebarEnabled,
      isScheduled,
      isSaving,
      isSavingNonPostEntityChanges,
      onClose,
      onTogglePublishSidebar,
      PostPublishExtension,
      PrePublishExtension,
      ...additionalProps
    } = this.props;
    const propsForPanel = (0, _lodash.omit)(additionalProps, ['hasPublishAction', 'isDirty', 'isPostTypeViewable']);
    const isPublishedOrScheduled = isPublished || isScheduled && isBeingScheduled;
    const isPrePublish = !isPublishedOrScheduled && !isSaving;
    const isPostPublish = isPublishedOrScheduled && !isSaving;
    return (0, _element.createElement)("div", (0, _extends2.default)({
      className: "editor-post-publish-panel"
    }, propsForPanel), (0, _element.createElement)("div", {
      className: "editor-post-publish-panel__header"
    }, isPostPublish ? (0, _element.createElement)(_components.Button, {
      onClick: onClose,
      icon: _icons.closeSmall,
      label: (0, _i18n.__)('Close panel')
    }) : (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("div", {
      className: "editor-post-publish-panel__header-publish-button"
    }, (0, _element.createElement)(_postPublishButton.default, {
      focusOnMount: true,
      onSubmit: this.onSubmit,
      forceIsDirty: forceIsDirty,
      forceIsSaving: forceIsSaving
    })), (0, _element.createElement)("div", {
      className: "editor-post-publish-panel__header-cancel-button"
    }, (0, _element.createElement)(_components.Button, {
      disabled: isSavingNonPostEntityChanges,
      onClick: onClose,
      variant: "secondary"
    }, (0, _i18n.__)('Cancel'))))), (0, _element.createElement)("div", {
      className: "editor-post-publish-panel__content"
    }, isPrePublish && (0, _element.createElement)(_prepublish.default, null, PrePublishExtension && (0, _element.createElement)(PrePublishExtension, null)), isPostPublish && (0, _element.createElement)(_postpublish.default, {
      focusOnMount: true
    }, PostPublishExtension && (0, _element.createElement)(PostPublishExtension, null)), isSaving && (0, _element.createElement)(_components.Spinner, null)), (0, _element.createElement)("div", {
      className: "editor-post-publish-panel__footer"
    }, (0, _element.createElement)(_components.CheckboxControl, {
      label: (0, _i18n.__)('Always show pre-publish checks.'),
      checked: isPublishSidebarEnabled,
      onChange: onTogglePublishSidebar
    })));
  }

}

exports.PostPublishPanel = PostPublishPanel;

var _default = (0, _compose.compose)([(0, _data.withSelect)(select => {
  const {
    getPostType
  } = select(_coreData.store);
  const {
    getCurrentPost,
    getEditedPostAttribute,
    isCurrentPostPublished,
    isCurrentPostScheduled,
    isEditedPostBeingScheduled,
    isEditedPostDirty,
    isSavingPost,
    isSavingNonPostEntityChanges
  } = select(_store.store);
  const {
    isPublishSidebarEnabled
  } = select(_store.store);
  const postType = getPostType(getEditedPostAttribute('type'));
  return {
    hasPublishAction: (0, _lodash.get)(getCurrentPost(), ['_links', 'wp:action-publish'], false),
    isPostTypeViewable: (0, _lodash.get)(postType, ['viewable'], false),
    isBeingScheduled: isEditedPostBeingScheduled(),
    isDirty: isEditedPostDirty(),
    isPublished: isCurrentPostPublished(),
    isPublishSidebarEnabled: isPublishSidebarEnabled(),
    isSaving: isSavingPost(),
    isSavingNonPostEntityChanges: isSavingNonPostEntityChanges(),
    isScheduled: isCurrentPostScheduled()
  };
}), (0, _data.withDispatch)((dispatch, {
  isPublishSidebarEnabled
}) => {
  const {
    disablePublishSidebar,
    enablePublishSidebar
  } = dispatch(_store.store);
  return {
    onTogglePublishSidebar: () => {
      if (isPublishSidebarEnabled) {
        disablePublishSidebar();
      } else {
        enablePublishSidebar();
      }
    }
  };
}), _components.withFocusReturn, _components.withConstrainedTabbing])(PostPublishPanel);

exports.default = _default;
//# sourceMappingURL=index.js.map