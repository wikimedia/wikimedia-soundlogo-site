"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ListViewBranch;

var _element = require("@wordpress/element");

var _lodash = require("lodash");

var _data = require("@wordpress/data");

var _block = _interopRequireDefault(require("./block"));

var _appender = _interopRequireDefault(require("./appender"));

var _utils = require("./utils");

var _context = require("./context");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function ListViewBranch(props) {
  const {
    blocks,
    selectBlock,
    showAppender,
    showBlockMovers,
    showNestedBlocks,
    parentBlockClientId,
    level = 1,
    terminatedLevels = [],
    path = [],
    isBranchSelected = false,
    isLastOfBranch = false
  } = props;
  const {
    expandedState,
    expand,
    collapse,
    draggedClientIds,
    selectedClientIds
  } = (0, _context.useListViewContext)();
  const isTreeRoot = !parentBlockClientId;
  const filteredBlocks = (0, _lodash.compact)(blocks);

  const itemHasAppender = parentClientId => showAppender && !isTreeRoot && (0, _utils.isClientIdSelected)(parentClientId, selectedClientIds);

  const hasAppender = itemHasAppender(parentBlockClientId); // Add +1 to the rowCount to take the block appender into account.

  const blockCount = filteredBlocks.length;
  const rowCount = hasAppender ? blockCount + 1 : blockCount;
  const appenderPosition = rowCount;
  return (0, _element.createElement)(_element.Fragment, null, (0, _lodash.map)(filteredBlocks, (block, index) => {
    var _expandedState$client;

    const {
      clientId,
      innerBlocks
    } = block;
    const position = index + 1;
    const isLastRowAtLevel = rowCount === position;
    const updatedTerminatedLevels = isLastRowAtLevel ? [...terminatedLevels, level] : terminatedLevels;
    const updatedPath = [...path, position];
    const hasNestedBlocks = showNestedBlocks && !!innerBlocks && !!innerBlocks.length;
    const hasNestedAppender = itemHasAppender(clientId);
    const hasNestedBranch = hasNestedBlocks || hasNestedAppender;
    const isSelected = (0, _utils.isClientIdSelected)(clientId, selectedClientIds);
    const isSelectedBranch = isBranchSelected || isSelected && hasNestedBranch; // Logic needed to target the last item of a selected branch which might be deeply nested.
    // This is currently only needed for styling purposes. See: `.is-last-of-selected-branch`.

    const isLastBlock = index === blockCount - 1;
    const isLast = isSelected || isLastOfBranch && isLastBlock;
    const isLastOfSelectedBranch = isLastOfBranch && !hasNestedBranch && isLastBlock;
    const isExpanded = hasNestedBranch ? (_expandedState$client = expandedState[clientId]) !== null && _expandedState$client !== void 0 ? _expandedState$client : true : undefined;

    const selectBlockWithClientId = event => {
      event.stopPropagation();
      selectBlock(clientId);
    };

    const toggleExpanded = event => {
      event.stopPropagation();

      if (isExpanded === true) {
        collapse(clientId);
      } else if (isExpanded === false) {
        expand(clientId);
      }
    }; // Make updates to the selected or dragged blocks synchronous,
    // but asynchronous for any other block.


    const isDragged = !!(draggedClientIds !== null && draggedClientIds !== void 0 && draggedClientIds.includes(clientId));
    return (0, _element.createElement)(_data.AsyncModeProvider, {
      key: clientId,
      value: !isSelected
    }, (0, _element.createElement)(_block.default, {
      block: block,
      onClick: selectBlockWithClientId,
      onToggleExpanded: toggleExpanded,
      isDragged: isDragged,
      isSelected: isSelected,
      isBranchSelected: isSelectedBranch,
      isLastOfSelectedBranch: isLastOfSelectedBranch,
      level: level,
      position: position,
      rowCount: rowCount,
      siblingBlockCount: blockCount,
      showBlockMovers: showBlockMovers,
      terminatedLevels: terminatedLevels,
      path: updatedPath,
      isExpanded: isExpanded
    }), hasNestedBranch && isExpanded && !isDragged && (0, _element.createElement)(ListViewBranch, {
      blocks: innerBlocks,
      selectBlock: selectBlock,
      isBranchSelected: isSelectedBranch,
      isLastOfBranch: isLast,
      showAppender: showAppender,
      showBlockMovers: showBlockMovers,
      showNestedBlocks: showNestedBlocks,
      parentBlockClientId: clientId,
      level: level + 1,
      terminatedLevels: updatedTerminatedLevels,
      path: updatedPath
    }));
  }), hasAppender && (0, _element.createElement)(_appender.default, {
    parentBlockClientId: parentBlockClientId,
    position: rowCount,
    rowCount: appenderPosition,
    level: level,
    terminatedLevels: terminatedLevels,
    path: [...path, appenderPosition]
  }));
}

ListViewBranch.defaultProps = {
  selectBlock: () => {}
};
//# sourceMappingURL=branch.js.map