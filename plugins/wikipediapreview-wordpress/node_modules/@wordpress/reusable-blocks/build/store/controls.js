"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertBlockToStatic = convertBlockToStatic;
exports.convertBlocksToReusable = convertBlocksToReusable;
exports.deleteReusableBlock = deleteReusableBlock;
exports.default = void 0;

var _lodash = require("lodash");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _i18n = require("@wordpress/i18n");

var _blockEditor = require("@wordpress/block-editor");

var _index = require("./index.js");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Convert a reusable block to a static block effect handler
 *
 * @param {string} clientId Block ID.
 * @return {Object} control descriptor.
 */
function convertBlockToStatic(clientId) {
  return {
    type: 'CONVERT_BLOCK_TO_STATIC',
    clientId
  };
}
/**
 * Convert a static block to a reusable block effect handler
 *
 * @param {Array}  clientIds Block IDs.
 * @param {string} title     Reusable block title.
 * @return {Object} control descriptor.
 */


function convertBlocksToReusable(clientIds, title) {
  return {
    type: 'CONVERT_BLOCKS_TO_REUSABLE',
    clientIds,
    title
  };
}
/**
 * Deletes a reusable block.
 *
 * @param {string} id Reusable block ID.
 * @return {Object} control descriptor.
 */


function deleteReusableBlock(id) {
  return {
    type: 'DELETE_REUSABLE_BLOCK',
    id
  };
}

const controls = {
  CONVERT_BLOCK_TO_STATIC: (0, _data.createRegistryControl)(registry => ({
    clientId
  }) => {
    const oldBlock = registry.select(_blockEditor.store).getBlock(clientId);
    const reusableBlock = registry.select('core').getEditedEntityRecord('postType', 'wp_block', oldBlock.attributes.ref);
    const newBlocks = (0, _blocks.parse)((0, _lodash.isFunction)(reusableBlock.content) ? reusableBlock.content(reusableBlock) : reusableBlock.content);
    registry.dispatch(_blockEditor.store).replaceBlocks(oldBlock.clientId, newBlocks);
  }),
  CONVERT_BLOCKS_TO_REUSABLE: (0, _data.createRegistryControl)(registry => async function ({
    clientIds,
    title
  }) {
    const reusableBlock = {
      title: title || (0, _i18n.__)('Untitled Reusable block'),
      content: (0, _blocks.serialize)(registry.select(_blockEditor.store).getBlocksByClientId(clientIds)),
      status: 'publish'
    };
    const updatedRecord = await registry.dispatch('core').saveEntityRecord('postType', 'wp_block', reusableBlock);
    const newBlock = (0, _blocks.createBlock)('core/block', {
      ref: updatedRecord.id
    });
    registry.dispatch(_blockEditor.store).replaceBlocks(clientIds, newBlock);

    registry.dispatch(_index.store).__experimentalSetEditingReusableBlock(newBlock.clientId, true);
  }),
  DELETE_REUSABLE_BLOCK: (0, _data.createRegistryControl)(registry => async function ({
    id
  }) {
    const reusableBlock = registry.select('core').getEditedEntityRecord('postType', 'wp_block', id); // Don't allow a reusable block with a temporary ID to be deleted

    if (!reusableBlock) {
      return;
    } // Remove any other blocks that reference this reusable block


    const allBlocks = registry.select(_blockEditor.store).getBlocks();
    const associatedBlocks = allBlocks.filter(block => (0, _blocks.isReusableBlock)(block) && block.attributes.ref === id);
    const associatedBlockClientIds = associatedBlocks.map(block => block.clientId); // Remove the parsed block.

    if (associatedBlockClientIds.length) {
      registry.dispatch(_blockEditor.store).removeBlocks(associatedBlockClientIds);
    }

    await registry.dispatch('core').deleteEntityRecord('postType', 'wp_block', id);
  })
};
var _default = controls;
exports.default = _default;
//# sourceMappingURL=controls.js.map